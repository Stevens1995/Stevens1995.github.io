<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Truly reactive programming with Svelte3.0]]></title>
    <url>%2FTruly-reactive-programming-with-Svelte3-0%2F</url>
    <content type="text"><![CDATA[本文是一篇翻译过来的文章，原文地址：https://blog.logrocket.com/truly-reactive-programming-with-svelte-3-0-321b49b75969这个标题有点戏剧性，但是话又说回来，Svelte背后的想法正是如此。如果你还不知道Svelte是什么，那赶紧过来瞅瞅 — 你将会看到一场革命，并且Svelte将会取得最后的胜利（并不是在对Svelte团队施加压力哈😅）。请注意本文并不是学习和使用Svelte的教程。Svelte团队已经提供了一份很棒的一步一步的互动式教程，以便帮助你走进反应式编程的世界。免责声明：我不是编程界的摇滚明星，我不可能知道所有事情。我只是对每天发生的新鲜事情感到好奇，并且在我可以的时候分享- 于是就有了这篇文章。请带着一些怀疑的想法来看待这里我所说的事情，并且，如果我说了一些愚蠢的话，麻烦及时让我知道。好嘞！让我们开始吧！💥首先，关于React在我开始讨论为什么Svelte如此强大之前，我们先来看看Dan的一条推文，一段时间后我们再来看看其中表达的意思：React is not fully reactive&mdash; Dan Abramov (@dan_abramov) 2018年8月4日另一份免责声明：这篇文章也不是以任何方式批评和攻击React。我只是简单地决定用React作为一个学习案例，因为此文的大部分读者应该都用过一点React。React是跟Svelte对比的一个很好地案例。Dan到底想表达什么，这对我们现在的编程方式有何影响呢？在回答这个问题前，让我简单地向你介绍下React背后的工作原理。当你渲染一个React应用时，React保存了一份DOM的拷贝，称作虚拟DOM。虚拟DOM充当你的React代码和浏览器渲染DOM之间的中间人。每当你的数据改变时（比如当你调用this.setState，useState），React做了一点工作来决定如何重绘屏幕上的UI。数据更新后，React会对比虚拟DOM和真实DOM，并且只更新两者间不同的地方。这样就避免了每次数据改变时都要重新渲染整个DOM。现在，一切都变得很迅速，因为更新虚拟DOM比更新真实DOM所耗费的性能小很多，React只更新了真实DOM确实需要更新的部分。这篇文章很好地讲述了整个过程。但是！但是啊，聪明的你可能已经注意到了一些事情。那就是，如果你不告诉React你的数据发生了改变（比如，通过调用this.setState或者钩子函数），你的虚拟DOM就不会发生改变，React就不再react了。（ba dum tss! 🤓）（这句翻译不来…有点像 dumb ass…）这就是Dan为什么说React不是完全reactive的原因。React依赖用户来跟踪应用中的数据，通过用来告诉自己数据发生了改变，但这对用户来说通常是额外的工作。OK，让我们来看看SvelteSvelte提供一种全新的方式来搭建超级快速，高效，真正响应式行为的UI。没有虚拟DOM，并且代码行数比所有其他你用过框架或者包更少。这听起来很棒，但是它与众多的JavaScript框架有什么不同呢？Let me show you 😏真正的反应式Svelte不是一个包或者框架。Svelte是一个编译器，它接受原生的JavaScript代码，输出的Javascript也是直接与DOM交互，而不需要任何其他东西充当中介。等一下？什么？一个编译器？（作者戏真多…）。 是的----- 一个编译器。这是一个非常棒的想法，我不明白为什么直到现在Svelte还不是很惹人注意，现在，让我来告诉你为什么Svelte是那么地酷炫。以下是Rich Harris在YGLF 2019年会议上的讲话：Svelte 3.0将反应性从组件API移入语言中。(Svelte 3.0 moves reactivity out of the component API and into the language.)这句话是什么意思呢？我们已经知道了React（以及很多其他的前端框架）需要你调用特定的API来告诉其数据发生了改变（通过调用this.setState或者useState）才能更新它的虚拟DOM。在React中，需要调用this.setState意味着你的应用的反应性其实是绑定在特定的API上，没有这些API，数据的改变并不会被注意到。而Svelte通过另一种方式来实现反应性。Svelte从Observable运行代码的方式中获取到了灵感，以拓扑代替从上至下的方式来运行代码。我们通过下面这段代码来看看什么是通过拓扑顺序来执行代码：12345678(() =&gt; &#123; const square =&gt; number =&gt; number * number; const secondNumber = square(firstNumber); const firstNumber = 42; console.log(secondNumber); &#125;)(); 如果你从上至下运行这段代码的话，解释到在第4行的时候，程序会报错。因为secondNunmber依赖于firstNumber，但firstNumber还没有被定义。但是如果程序以拓扑的方式来执行的话，程序不会报任何错误。为什么呢？以为编译器不会自上而下执行代码，而是会查看所有的变量从而生成一个依赖图（即谁被需要谁先被执行） 在上述的例子中，要理解编译器如果以拓扑的方式编译代码很简单： square变量依赖其他变量吗？ -没有，初始化square secondNumber依赖于其他变量吗？ -secondNumber依赖于square和firstNumber,square已经被初始化，但是firstNumber还没有被初始化，初始化firstNumber OK，firstNumber已经被初始化，现在可以用firstNumber和square来初始化secondNumber -还有其他的变量需要初始化吗？没有-执行代码 乍一看，这段代码似乎依然是从上到下执行的，但是仔细看的话，你会发现实际上代码执行时会有一些跳转。 当代码执行到第四行时，编译器发现firstNumber并没有被定义，于是编译器暂停解释该语句，并且在你的代码中寻找该变量的定义。当找到firstNumber在第五行被定义后，第五行会先于第四行执行，当第五行执行完毕后，再返回执行第四行。 TL;DR：如果语句A依赖于语句B，不管语句声明的顺序如何，B将先于A执行 Svelte是如何应用上述的原理以实现真正的反应式呢？在Svelte中，你可以用一个标识符来表示一个语句，像这样：$: foo = bar。这样做之后，语句foo = bar就有了一个表示$（上述语句在严格模式下会报错） 当Svelte看到任何有$前缀的语句时，编译器就知道左边的变量由右边的变量导出。于是，现在我们有了将一个变量绑定在另一个变量的方法。 Reactivity!(反应式!)这意味着现在我们用JavaScript的原生API来实现真正的响应式，而无需再摆弄一些三方API，比如this.setState。 下面的代码是这样写的实际效果： 123456789// vanilla jslet foo = 10;let bar = foo + 10; // bar is now 20foo = bar // bar is still 20 (no reactivity)bar = foo + 5 // now bar becomes 25// svelte jslet foo = 10;$: bar = foo + 10; // bar is now 20foo = 15 // bar is now 25 because it is bound to the value of foo 在上述的Svelte代码中，我们并不需要将foo的新值重新赋值给bar，代码会帮我们自动处理。当你把foo的值更改为15时，bar会自动更新为25。 上述的Svelte代码经过编译后，大概便变成这样： 1234567891011... omitted for brevity ...function instance($$self, $$props, $$invalidate) &#123; let foo = 10; // bar is now 20 $$invalidate('foo', foo = 15) // bar is now 25 because it is bound to the value of foo let bar; $$self.$$.update = ($$dirty = &#123; foo: 1 &#125;) =&gt; &#123; if ($$dirty.foo) &#123; $$invalidate('bar', bar = foo + 19); &#125; &#125;; return &#123; bar &#125;; &#125;... omitted for brevity ... 花点时间认真看看上面的代码，真的，认真看下。 你看到foo是如何更新的吗？即使是在bar没有被定义之前。（我暂时没看懂…）这是因为Svelte的编译器以拓扑的顺序来执行代码，而不是自上而下。 Svelte自动对数据的更新做出改变，而不需要用户关系改变的内容和时间，这一切都是自动进行的。用户可以专注于代码逻辑，让Svelte根据应用状态的改变来调节UI。 简洁 记得我说过Svelte可以用更少的代码来做到相同的工作吗？我是认真的！看看下面这个组件分别用Svelte和React实现的版本： 17行代码 vs 29行代码 上述两个应用实现的功能几乎完全一样，但是你可以看到在React.js中，我们不得不编写更多地代码 ---- Angular里面更过分。 Svelte简洁的代码除了看起来更方便之外，同时也更利于逻辑的判断和推理，因为代码中没有其他冗余的部分。我们不需要事件处理程序来更新input输入–简单的绑定就可以了。 假如你是一个刚刚入门的web开发者，哪一种方式学习起来更加简单？左边？还是右边？ 或许你认为仅仅是少一点代码看起来很微不足道，但是当你所负责的项目变得越来越大，越来越复杂时，简洁的代码就变得很重要。我个人发现，有时候需要花费数个小时才能理解一个同事写的React组件。 性能 OK，我们已经见识到了Svelte如何实现真正的反应式，并且让我们的代码更加简短和简洁。那么性能呢？如果用Svelte来编写完整的应用，用户体验如何？ 一个让React如此强大的原因是React使用虚拟DOM来更新UI中很少的一部分，避免了每次数据改变时都重绘整个DOM。但是，这种方法有一个缺点是，当一个React组件改变时，React会重新渲染所有的子组件，不管子组件是否有重新渲染的必要。这就是为什么React提供了shouldComponentUpdate，useMemo，React.PureComponent等API。只要使用虚拟DOM来更新UI，这个问题就会一直存在。 Svelte没有使用虚拟DOM，那么她是如何根据应用的状态来同步更新UI的呢？让我再次引用Rich Harris的精彩YGLF演讲： Frameworks are not tools for organizing your code. They are tools for organizing your mind. 框架不是组织代码的工具，框架是用来组织你的思想的。 正是上面的引用给Rich带来了框架能够在构建阶段运行的灵感，这样代码在运行时就不需要其他中介。这个灵感也导致了Svelte是编译器，而不是框架。 这个简单的想法正是Svelte如此快速的原因。Svelte将你的代码编译为更底层的高效的代码，直接与DOM交互。 上面这些都很棒，但是Svelte是如何避免数据改变时重绘整个DOM呢？Svelte与React的差异在于如何感知数据的改变。我们已经知道，React依赖于用户调用API来感知数据改变，而Svelte只需要简单的使用=就可以了。 如果一个变量—我们假设foo—通过=进行了更新，Svelte只会更新其他依赖于foo的变量。这允许Svelte只更新部分从foo变量中获取值的DOM。 关于其中的细节，可以看Rich的解释 最后一点想法 Svelte3.0是一段时间内发生的关于软件开发的最好的事情。有些人可以说这有些夸大其词，但是我不这么认为。Svelte背后的理念使得我们在向浏览器中引用更少的模板的同时，做更多的事情。应用也会因此变得更加高性能，更加轻便，同时代码也变得更加优雅和易读。那现在是不是Svelte可以马上取代React，Angular，Vue或者其他前端框架吗？ 到目前为止，答案是否定的。相比于这些框架，Svelte相对来说还不是很成熟。它需要时间去成长，变得更加成熟，甚至解决一些目前我们还没有发现的问题。 就像React横空出世改变软件开发模式一样，Svelte也有可能改变我们关于框架的看法，在我们创建新的项目时提供无限可能。 最后，Happy Coding!]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>翻译</tag>
        <tag>新鲜货</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript Clean Code - Best Practices]]></title>
    <url>%2FJavaScript-Clean-Code-Best-Practices%2F</url>
    <content type="text"><![CDATA[本文是一篇翻译过来的文章，原文地址：https://devinduct.com/blogpost/22/javascript-clean-code-best-practices介绍如果你关心代码本身以及代码是如何被编写的，而不是仅仅关心代码是否有效，你可以说你练习并且关心整洁的代码。一个专业的开发人员会为未来的自己以及其他人员编写代码，而不仅仅是为了机器。你所编写的任何代码都不会只被编写一次，相反，它会静静地等待下一个接手的人，并且让他头大。希望那个人不是你~基于此，整洁的代码可以被定义为具有以下特征的代码：良好的可读性，便于被人所理解，易于修改和扩展。问问你自己，有多少次你接手别人的工作时你的第一印象时下面的**“WTF”** 问题之一：&quot;WTF is that?&quot;&quot;WTF did you do here?&quot;&quot;WTF is this for?&quot;下面这张图片很好地展示了上述内容：**Robert C. Martin(Uncle Bob)**的一句话应该会让你思考你写代码的方式：虽然糟糕的代码也可以运行，但是如果代码不整洁，它会让开发组织陷入困境。(Even bad code can function. But if the code isn’t clean, it can bring a development organization to its knees.)在这边文章中将会把注意力放在JavaScript上，但是文章中所说的一些原则也可以被应用在其他编程语言中。你真正来这阅读的部分-整洁代码 最佳实践强类型检查使用 === 代替 ==1234567891011121314151617// If not handled properly, it can dramatically affect the program logic. It's like, you expect to go left, but for some reason, you go right.0 == false // true0 === false // false2 == "2" // true2 === "2" // false// exampleconst value = "500";if (value === 500) &#123; console.log(value); // it will not be reached&#125;if (value === "500") &#123; console.log(value); // it will be reached&#125; 变量 变量名应该能够解释变量背后的意图和作用，这样会使变量变得易于搜索和理解。 坏代码： 1234567let daysSLV = 10;let y = new Date().getFullYear();let ok;if (user.age &gt; 30) &#123; ok = true;&#125; 好代码： 1234567const MAX_AGE = 30;let daysSinceLastVisit = 10;let currentYear = new Date().getFullYear();...const isUserOlderThanAllowed = user.age &gt; MAX_AGE; 不要在变量名中添加额外的不必要的单词 坏代码： 12let nameValue;let theProduct; 好代码： 12let name;let product; 不要让变量的含义依附上下文 坏代码： 1234567891011const users = ["John", "Marco", "Peter"];users.forEach(u =&gt; &#123; doSomething(); doSomethingElse(); // ... // ... // ... // ... // Here we have the WTF situation: WTF is `u` for? register(u);&#125;); 好代码： 12345678910const users = ["John", "Marco", "Peter"];users.forEach(user =&gt; &#123; doSomething(); doSomethingElse(); // ... // ... // ... // ... register(user);&#125;); 不要添加不必要的上下文 坏代码： 123456789const user = &#123; userName: "John", userSurname: "Doe", userAge: "28"&#125;;...user.userName; 好代码： 123456789const user = &#123; name: "John", surname: "Doe", age: "28"&#125;;...user.name; 函数 使用长的具有描述性的名字，考虑将函数名定义成一种行为。函数名应该是一个动词或者短语，并且完全暴露函数功能和变量名的作用。 坏代码： 123function notif(user) &#123; // implementation&#125; 123function notifyUser(emailAddress) &#123; // implementation&#125; 避免使用过多的参数。理想的情况下，一个函数的变量不应该超过两个。函数的变量越少越容易进行测试。 坏代码： 123function getUsers(fields, fromDate, toDate) &#123; // implementation&#125; 好代码： 123456789function getUsers(&#123; fields, fromDate, toDate &#125;) &#123; // implementation&#125;getUsers(&#123; fields: ['name', 'surname', 'email'], fromDate: '2019-01-01', toDate: '2019-01-18'&#125;); 使用默认参数值代替条件语句 坏代码： 1234function createShape(type) &#123; const shapeType = type || "cube"; // ...&#125; 好代码： 123function createShape(type = "cube") &#123; // ...&#125; 每个函数应该只做一件事情（SRP 单一职责原则）。避免在一个函数中执行过多的动作。 坏代码： 12345678function notifyUsers(users) &#123; users.forEach(user =&gt; &#123; const userRecord = database.lookup(user); if (userRecord.isVerified()) &#123; notify(user); &#125; &#125;);&#125; 好代码： 12345678function notifyVerifiedUsers(users) &#123; users.filter(isUserVerified).forEach(notify);&#125;function isUserVerified(user) &#123; const userRecord = database.lookup(user); return userRecord.isVerified();&#125; 使用Object.assign设置默认对象属性 坏代码： 12345678910111213const shapeConfig = &#123; type: "cube", width: 200, height: null&#125;;function createShape(config) &#123; config.type = config.type || "cube"; config.width = config.width || 250; config.height = config.width || 250;&#125;createShape(shapeConfig); 好代码： 1234567891011121314151617181920const shapeConfig = &#123; type: "cube", width: 200 // Exclude the 'height' key&#125;;function createShape(config) &#123; config = Object.assign( &#123; type: "cube", width: 250, height: 250 &#125;, config ); ...&#125;createShape(shapeConfig); 不要在参数中设置flag，应该这些flag表明函数在做额外的操作。 坏代码： 1234567function createFile(name, isPublic) &#123; if (isPublic) &#123; fs.create(`./public/$&#123;name&#125;`); &#125; else &#123; fs.create(name); &#125;&#125; 好代码： 1234567function createFile(name) &#123; fs.create(name);&#125;function createPublicFile(name) &#123; createFile(`./public/$&#123;name&#125;`);&#125; 不要污染默认的全局对象，如果你需要扩展一个已经存在的对象，使用ES6中的类和继承，不要直接修改原生对象的原型链 坏代码： 123Array.prototype.myFunc = function myFunc() &#123; // implementation&#125;; 好代码： 12345class SuperArray extends Array &#123; myFunc() &#123; // implementation &#125;&#125; 条件语句 避免否定的条件语句 坏代码： 1234567function isUserNotBlocked(user) &#123; // implementation&#125;if (!isUserNotBlocked(user)) &#123; // implementation&#125; 好代码： 1234567function isUserBlocked(user) &#123; // implementation&#125;if (isUserBlocked(user)) &#123; // implementation&#125; 当确定值为Boolean而不是undefined或者null时，使用短的条件语句。这可能是很小的细节，但是却值得一提。 坏代码： 1234567if (isValid === true) &#123; // do something...&#125;if (isValid === false) &#123; // do something...&#125; 好代码： 1234567if (isValid) &#123; // do something...&#125;if (!isValid) &#123; // do something...&#125; 尽可能避免条件语句，使用继承和多态来代替 坏代码： 12345678910111213class Car &#123; // ... getMaximumSpeed() &#123; switch (this.type) &#123; case "Ford": return this.someFactor() + this.anotherFactor(); case "Mazda": return this.someFactor(); case "McLaren": return this.someFactor() - this.anotherFactor(); &#125; &#125;&#125; 好代码： 123456789101112131415161718192021222324class Car &#123; // ...&#125;class Ford extends Car &#123; // ... getMaximumSpeed() &#123; return this.someFactor() + this.anotherFactor(); &#125;&#125;class Mazda extends Car &#123; // ... getMaximumSpeed() &#123; return this.someFactor(); &#125;&#125;class McLaren extends Car &#123; // ... getMaximumSpeed() &#123; return this.someFactor() - this.anotherFactor(); &#125;&#125; ES 类 Class是JavaScript中的语法糖，使用的也是原型继承。在代码中你应该使用ES6中的Class语法糖代码原生构造函数。 坏代码： 12345678910111213141516171819202122const Person = function(name) &#123; if (!(this instanceof Person)) &#123; throw new Error("Instantiate Person with `new` keyword"); &#125; this.name = name;&#125;;Person.prototype.sayHello = function sayHello() &#123; /**/ &#125;;const Student = function(name, school) &#123; if (!(this instanceof Student)) &#123; throw new Error("Instantiate Student with `new` keyword"); &#125; Person.call(this, name); this.school = school;&#125;;Student.prototype = Object.create(Person.prototype);Student.prototype.constructor = Student;Student.prototype.printSchoolName = function printSchoolName() &#123; /**/ &#125;; 好代码： 1234567891011121314151617181920class Person &#123; constructor(name) &#123; this.name = name; &#125; sayHello() &#123; /* ... */ &#125;&#125;class Student extends Person &#123; constructor(name, school) &#123; super(name); this.school = school; &#125; printSchoolName() &#123; /* ... */ &#125;&#125; 使用方法链。包括JQuery和Lodash在内的很多包都使用了这种模式。这样做的好处是，你的代码会看起来更加简洁。在你的类中，简单地在方法中返回this关键字，你就可以将更多地类方法串接起来。 坏代码： 12345678910111213141516171819202122class Person &#123; constructor(name) &#123; this.name = name; &#125; setSurname(surname) &#123; this.surname = surname; &#125; setAge(age) &#123; this.age = age; &#125; save() &#123; console.log(this.name, this.surname, this.age); &#125;&#125;const person = new Person("John");person.setSurname("Doe");person.setAge(29);person.save(); 好代码： 12345678910111213141516171819202122232425262728class Person &#123; constructor(name) &#123; this.name = name; &#125; setSurname(surname) &#123; this.surname = surname; // Return this for chaining return this; &#125; setAge(age) &#123; this.age = age; // Return this for chaining return this; &#125; save() &#123; console.log(this.name, this.surname, this.age); // Return this for chaining return this; &#125;&#125;const person = new Person("John") .setSurname("Doe") .setAge(29) .save(); 普遍的需要注意和避免的地方 一般来说，你应该尽可能地避免编写重复的代码，以及在代码中留下用不到的死代码。 你可能会因为各种原因在代码中编写冗余的代码。比如说，你有两个很相似的对象，彼此间只有一点点的不同。但是由于他们的不同点的本质，或者紧迫的项目排期，你不得不创建两个几乎拥有相同的代码的类或者函数。而想要去除这些冗余的代码意味着抽象出不同点，在更高的层次上来执行操作。 关于死代码，指的是那些再也用不到的代码，可能在项目开发的某个节点，你的一些决定让这些代码不再包含任何的用途。你应该在代码库中搜索并删除所有用不到的函数和代码块。我的一个建议是，一旦你决定某些代码不再被需要，马上删除它。否则你可能会忘记的~ 下面这张图片表明了你看到一些死代码但是又不记得是否有作用时的感受： when you forget the purpose of dead code 总结 上面所描述的只是你能的优化代码的一小部分。这里所描述的原则，是我个人看来人们经常不遵守的原则。人们尝试着去遵守这些原则，但是往往由于各种原因导致失败。可能在项目开始的时候，代码很简洁、整齐，但是当排期越来越近时，这些原则经常都会被忽略并且被移到**&quot;TODO&quot;或者REFACTOR**的部分。在这些时候，客户更关心的是排期的截止，而不是编写更加简洁的代码。]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>翻译</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>

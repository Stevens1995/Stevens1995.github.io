<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Truly reactive programming with Svelte3.0]]></title>
    <url>%2FTruly-reactive-programming-with-Svelte3-0%2F</url>
    <content type="text"><![CDATA[本文是一篇翻译过来的文章，原文地址：https://blog.logrocket.com/truly-reactive-programming-with-svelte-3-0-321b49b75969这个标题有点戏剧性，但是话又说回来，Svelte背后的想法正是如此。如果你还不知道Svelte是什么，那赶紧过来瞅瞅 — 你将会看到一场革命，并且Svelte将会取得最后的胜利（并不是在对Svelte团队施加压力哈😅）。请注意本文并不是学习和使用Svelte的教程。Svelte团队已经提供了一份很棒的一步一步的互动式教程，以便帮助你走进反应式编程的世界。免责声明：我不是编程界的摇滚明星，我不可能知道所有事情。我只是对每天发生的新鲜事情感到好奇，并且在我可以的时候分享- 于是就有了这篇文章。请带着一些怀疑的想法来看待这里我所说的事情，并且，如果我说了一些愚蠢的话，麻烦及时让我知道。好嘞！让我们开始吧！💥首先，关于React在我开始讨论为什么Svelte如此强大之前，我们先来看看Dan的一条推文，一段时间后我们再来看看其中表达的意思：react is not fully reactive另一份免责声明：这篇文章也不是以任何方式批评和攻击React。我只是简单地决定用React作为一个学习案例，因为此文的大部分读者应该都用过一点React。React是跟Svelte对比的一个很好地案例。Dan到底想表达什么，这对我们现在的编程方式有何影响呢？在回答这个问题前，让我简单地向你介绍下React背后的工作原理。当你渲染一个React应用时，React保存了一份DOM的拷贝，称作虚拟DOM。虚拟DOM充当你的React代码和浏览器渲染DOM之间的中间人。每当你的数据改变时（比如当你调用this.setState，useState），React做了一点工作来决定如何重绘屏幕上的UI。数据更新后，React会对比虚拟DOM和真实DOM，并且只更新两者间不同的地方。这样就避免了每次数据改变时都要重新渲染整个DOM。现在，一切都变得很迅速，因为更新虚拟DOM比更新真实DOM所耗费的性能小很多，React只更新了真实DOM确实需要更新的部分。这篇文章很好地讲述了整个过程。但是！但是啊，聪明的你可能已经注意到了一些事情。那就是，如果你不告诉React你的数据发生了改变（比如，通过调用this.setState或者钩子函数），你的虚拟DOM就不会发生改变，React就不再react了。（ba dum tss! 🤓）（这句翻译不来…有点像 dumb ass…）这就是Dan为什么说React不是完全reactive的原因。React依赖用户来跟踪应用中的数据，通过用来告诉自己数据发生了改变，但这对用户来说通常是额外的工作。OK，让我们来看看SvelteSvelte提供一种全新的方式来搭建超级快速，高效，真正响应式行为的UI。没有虚拟DOM，并且代码行数比所有其他你用过框架或者包更少。这听起来很棒，但是它与众多的JavaScript框架有什么不同呢？Let me show you 😏真正的反应式Svelte不是一个包或者框架。Svelte是一个编译器，它接受原生的JavaScript代码，输出的Javascript也是直接与DOM交互，而不需要任何其他东西充当中介。等一下？什么？一个编译器？（作者戏真多…）。 是的----- 一个编译器。这是一个非常棒的想法，我不明白为什么直到现在Svelte还不是很惹人注意，现在，让我来告诉你为什么Svelte是那么地酷炫。以下是Rich Harris在YGLF 2019年会议上的讲话：Svelte 3.0将反应性从组件API移入语言中。(Svelte 3.0 moves reactivity out of the component API and into the language.)这句话是什么意思呢？我们已经知道了React（以及很多其他的前端框架）需要你调用特定的API来告诉其数据发生了改变（通过调用this.setState或者useState）才能更新它的虚拟DOM。在React中，需要调用this.setState意味着你的应用的反应性其实是绑定在特定的API上，没有这些API，数据的改变并不会被注意到。而Svelte通过另一种方式来实现反应性。未完待续…]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>翻译</tag>
        <tag>新鲜货</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript Clean Code - Best Practices]]></title>
    <url>%2FJavaScript-Clean-Code-Best-Practices%2F</url>
    <content type="text"><![CDATA[本文是一篇翻译过来的文章，原文地址：https://devinduct.com/blogpost/22/javascript-clean-code-best-practices介绍如果你关心代码本身以及代码是如何被编写的，而不是仅仅关心代码是否有效，你可以说你练习并且关心整洁的代码。一个专业的开发人员会为未来的自己以及其他人员编写代码，而不仅仅是为了机器。你所编写的任何代码都不会只被编写一次，相反，它会静静地等待下一个接手的人，并且让他头大。希望那个人不是你~基于此，整洁的代码可以被定义为具有以下特征的代码：良好的可读性，便于被人所理解，易于修改和扩展。问问你自己，有多少次你接手别人的工作时你的第一印象时下面的**“WTF”** 问题之一：&quot;WTF is that?&quot;&quot;WTF did you do here?&quot;&quot;WTF is this for?&quot;下面这张图片很好地展示了上述内容：**Robert C. Martin(Uncle Bob)**的一句话应该会让你思考你写代码的方式：虽然糟糕的代码也可以运行，但是如果代码不整洁，它会让开发组织陷入困境。(Even bad code can function. But if the code isn’t clean, it can bring a development organization to its knees.)在这边文章中将会把注意力放在JavaScript上，但是文章中所说的一些原则也可以被应用在其他编程语言中。你真正来这阅读的部分-整洁代码 最佳实践强类型检查使用 === 代替 ==1234567891011121314151617// If not handled properly, it can dramatically affect the program logic. It's like, you expect to go left, but for some reason, you go right.0 == false // true0 === false // false2 == "2" // true2 === "2" // false// exampleconst value = "500";if (value === 500) &#123; console.log(value); // it will not be reached&#125;if (value === "500") &#123; console.log(value); // it will be reached&#125; 变量 变量名应该能够解释变量背后的意图和作用，这样会使变量变得易于搜索和理解。 坏代码： 1234567let daysSLV = 10;let y = new Date().getFullYear();let ok;if (user.age &gt; 30) &#123; ok = true;&#125; 好代码： 1234567const MAX_AGE = 30;let daysSinceLastVisit = 10;let currentYear = new Date().getFullYear();...const isUserOlderThanAllowed = user.age &gt; MAX_AGE; 不要在变量名中添加额外的不必要的单词 坏代码： 12let nameValue;let theProduct; 好代码： 12let name;let product; 不要让变量的含义依附上下文 坏代码： 1234567891011const users = ["John", "Marco", "Peter"];users.forEach(u =&gt; &#123; doSomething(); doSomethingElse(); // ... // ... // ... // ... // Here we have the WTF situation: WTF is `u` for? register(u);&#125;); 好代码： 12345678910const users = ["John", "Marco", "Peter"];users.forEach(user =&gt; &#123; doSomething(); doSomethingElse(); // ... // ... // ... // ... register(user);&#125;); 不要添加不必要的上下文 坏代码： 123456789const user = &#123; userName: "John", userSurname: "Doe", userAge: "28"&#125;;...user.userName; 好代码： 123456789const user = &#123; name: "John", surname: "Doe", age: "28"&#125;;...user.name; 函数 使用长的具有描述性的名字，考虑将函数名定义成一种行为。函数名应该是一个动词或者短语，并且完全暴露函数功能和变量名的作用。 坏代码： 123function notif(user) &#123; // implementation&#125; 123function notifyUser(emailAddress) &#123; // implementation&#125; 避免使用过多的参数。理想的情况下，一个函数的变量不应该超过两个。函数的变量越少越容易进行测试。 坏代码： 123function getUsers(fields, fromDate, toDate) &#123; // implementation&#125; 好代码： 123456789function getUsers(&#123; fields, fromDate, toDate &#125;) &#123; // implementation&#125;getUsers(&#123; fields: ['name', 'surname', 'email'], fromDate: '2019-01-01', toDate: '2019-01-18'&#125;); 使用默认参数值代替条件语句 坏代码： 1234function createShape(type) &#123; const shapeType = type || "cube"; // ...&#125; 好代码： 123function createShape(type = "cube") &#123; // ...&#125; 每个函数应该只做一件事情（SRP 单一职责原则）。避免在一个函数中执行过多的动作。 坏代码： 12345678function notifyUsers(users) &#123; users.forEach(user =&gt; &#123; const userRecord = database.lookup(user); if (userRecord.isVerified()) &#123; notify(user); &#125; &#125;);&#125; 好代码： 12345678function notifyVerifiedUsers(users) &#123; users.filter(isUserVerified).forEach(notify);&#125;function isUserVerified(user) &#123; const userRecord = database.lookup(user); return userRecord.isVerified();&#125; 使用Object.assign设置默认对象属性 坏代码： 12345678910111213const shapeConfig = &#123; type: "cube", width: 200, height: null&#125;;function createShape(config) &#123; config.type = config.type || "cube"; config.width = config.width || 250; config.height = config.width || 250;&#125;createShape(shapeConfig); 好代码： 1234567891011121314151617181920const shapeConfig = &#123; type: "cube", width: 200 // Exclude the 'height' key&#125;;function createShape(config) &#123; config = Object.assign( &#123; type: "cube", width: 250, height: 250 &#125;, config ); ...&#125;createShape(shapeConfig); 不要在参数中设置flag，应该这些flag表明函数在做额外的操作。 坏代码： 1234567function createFile(name, isPublic) &#123; if (isPublic) &#123; fs.create(`./public/$&#123;name&#125;`); &#125; else &#123; fs.create(name); &#125;&#125; 好代码： 1234567function createFile(name) &#123; fs.create(name);&#125;function createPublicFile(name) &#123; createFile(`./public/$&#123;name&#125;`);&#125; 不要污染默认的全局对象，如果你需要扩展一个已经存在的对象，使用ES6中的类和继承，不要直接修改原生对象的原型链 坏代码： 123Array.prototype.myFunc = function myFunc() &#123; // implementation&#125;; 好代码： 12345class SuperArray extends Array &#123; myFunc() &#123; // implementation &#125;&#125; 条件语句 避免否定的条件语句 坏代码： 1234567function isUserNotBlocked(user) &#123; // implementation&#125;if (!isUserNotBlocked(user)) &#123; // implementation&#125; 好代码： 1234567function isUserBlocked(user) &#123; // implementation&#125;if (isUserBlocked(user)) &#123; // implementation&#125; 当确定值为Boolean而不是undefined或者null时，使用短的条件语句。这可能是很小的细节，但是却值得一提。 坏代码： 1234567if (isValid === true) &#123; // do something...&#125;if (isValid === false) &#123; // do something...&#125; 好代码： 1234567if (isValid) &#123; // do something...&#125;if (!isValid) &#123; // do something...&#125; 尽可能避免条件语句，使用继承和多态来代替 坏代码： 12345678910111213class Car &#123; // ... getMaximumSpeed() &#123; switch (this.type) &#123; case "Ford": return this.someFactor() + this.anotherFactor(); case "Mazda": return this.someFactor(); case "McLaren": return this.someFactor() - this.anotherFactor(); &#125; &#125;&#125; 好代码： 123456789101112131415161718192021222324class Car &#123; // ...&#125;class Ford extends Car &#123; // ... getMaximumSpeed() &#123; return this.someFactor() + this.anotherFactor(); &#125;&#125;class Mazda extends Car &#123; // ... getMaximumSpeed() &#123; return this.someFactor(); &#125;&#125;class McLaren extends Car &#123; // ... getMaximumSpeed() &#123; return this.someFactor() - this.anotherFactor(); &#125;&#125; ES 类 Class是JavaScript中的语法糖，使用的也是原型继承。在代码中你应该使用ES6中的Class语法糖代码原生构造函数。 坏代码： 12345678910111213141516171819202122const Person = function(name) &#123; if (!(this instanceof Person)) &#123; throw new Error("Instantiate Person with `new` keyword"); &#125; this.name = name;&#125;;Person.prototype.sayHello = function sayHello() &#123; /**/ &#125;;const Student = function(name, school) &#123; if (!(this instanceof Student)) &#123; throw new Error("Instantiate Student with `new` keyword"); &#125; Person.call(this, name); this.school = school;&#125;;Student.prototype = Object.create(Person.prototype);Student.prototype.constructor = Student;Student.prototype.printSchoolName = function printSchoolName() &#123; /**/ &#125;; 好代码： 1234567891011121314151617181920class Person &#123; constructor(name) &#123; this.name = name; &#125; sayHello() &#123; /* ... */ &#125;&#125;class Student extends Person &#123; constructor(name, school) &#123; super(name); this.school = school; &#125; printSchoolName() &#123; /* ... */ &#125;&#125; 使用方法链。包括JQuery和Lodash在内的很多包都使用了这种模式。这样做的好处是，你的代码会看起来更加简洁。在你的类中，简单地在方法中返回this关键字，你就可以将更多地类方法串接起来。 坏代码： 12345678910111213141516171819202122class Person &#123; constructor(name) &#123; this.name = name; &#125; setSurname(surname) &#123; this.surname = surname; &#125; setAge(age) &#123; this.age = age; &#125; save() &#123; console.log(this.name, this.surname, this.age); &#125;&#125;const person = new Person("John");person.setSurname("Doe");person.setAge(29);person.save(); 好代码： 12345678910111213141516171819202122232425262728class Person &#123; constructor(name) &#123; this.name = name; &#125; setSurname(surname) &#123; this.surname = surname; // Return this for chaining return this; &#125; setAge(age) &#123; this.age = age; // Return this for chaining return this; &#125; save() &#123; console.log(this.name, this.surname, this.age); // Return this for chaining return this; &#125;&#125;const person = new Person("John") .setSurname("Doe") .setAge(29) .save(); 普遍的需要注意和避免的地方 一般来说，你应该尽可能地避免编写重复的代码，以及在代码中留下用不到的死代码。 你可能会因为各种原因在代码中编写冗余的代码。比如说，你有两个很相似的对象，彼此间只有一点点的不同。但是由于他们的不同点的本质，或者紧迫的项目排期，你不得不创建两个几乎拥有相同的代码的类或者函数。而想要去除这些冗余的代码意味着抽象出不同点，在更高的层次上来执行操作。 关于死代码，指的是那些再也用不到的代码，可能在项目开发的某个节点，你的一些决定让这些代码不再包含任何的用途。你应该在代码库中搜索并删除所有用不到的函数和代码块。我的一个建议是，一旦你决定某些代码不再被需要，马上删除它。否则你可能会忘记的~ 下面这张图片表明了你看到一些死代码但是又不记得是否有作用时的感受： when you forget the purpose of dead code 总结 上面所描述的只是你能的优化代码的一小部分。这里所描述的原则，是我个人看来人们经常不遵守的原则。人们尝试着去遵守这些原则，但是往往由于各种原因导致失败。可能在项目开始的时候，代码很简洁、整齐，但是当排期越来越近时，这些原则经常都会被忽略并且被移到**&quot;TODO&quot;或者REFACTOR**的部分。在这些时候，客户更关心的是排期的截止，而不是编写更加简洁的代码。]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>翻译</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>

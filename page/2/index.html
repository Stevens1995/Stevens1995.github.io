<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Hexo</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://stevens1995.github.io/atom.xml" title="Hexo"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/Stevens1995/Stevens1995.github.io" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/06/03/CommonJSvsAMDvsES2015module/" class="post-title-link">CommonJS vs AMD vs ES2015module</a></h2><div class="post-info">2017年6月3日</div><div class="post-content"><h4>常见的JavaScript模块系统总结，不同标准的特点以及区别。</h4>

<p>参考并翻译此文章: <a href="https://auth0.com/blog/javascript-module-systems-showdown/" target="_blank" rel="external">https://auth0.com/blog/javascript-module-systems-showdown/</a></p>
<p><strong><em>COMMONJS:</em></strong></p>
<p>CommonJS致力于定义一系列的规范来帮助进行服务端的JavaScript开发。其中一个CommonJS尝试解决的领</p>
<p>域就是模块化。Node.js开发者最初打算遵循CommonJS规范，但是后来决定放弃。但是node.js的实现很大</p>
<p>程度上受到了CommonJS的影响。（也就是说node.js并没有完全遵循CommonJS规范）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In circle.js</span></div><div class="line"><span class="keyword">const</span> PI = <span class="built_in">Math</span>.PI;</div><div class="line"></div><div class="line">exports.area = <span class="function">(<span class="params">r</span>) =&gt;</span> PI * r * r;</div><div class="line"></div><div class="line">exports.circumference = <span class="function">(<span class="params">r</span>) =&gt;</span> <span class="number">2</span> * PI * r;</div><div class="line"></div><div class="line"><span class="comment">// In some file</span></div><div class="line"><span class="keyword">const</span> circle = <span class="built_in">require</span>(<span class="string">'./circle.js'</span>);</div><div class="line"><span class="built_in">console</span>.log( <span class="string">`The area of a circle of radius 4 is <span class="subst">$&#123;circle.area(<span class="number">4</span>)&#125;</span>`</span>);</div></pre></td></tr></table></figure></div><a href="/2017/06/03/CommonJSvsAMDvsES2015module/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/05/30/javascript中几个概念/" class="post-title-link">javascript中几个概念</a></h2><div class="post-info">2017年5月30日</div><div class="post-content"><p>关于javascript中几个概念的解释:</p>
<p><strong><em>1.执行上下文（Execution Context）</em></strong></p>
<p>通俗来说就是函数执行时的环境，包括下面几个部分： </p>
<p>变量对象、作用域链、this</p>
<p><strong><em>2.活动对象（Activation Object）</em></strong></p>
<p>形参、arguments对象、函数中定义的变量和函数</p>
<p><strong><em>3.变量对象（Variable Object）</em></strong></p>
<p>在全局上下文中，global object</p>
<p>在函数中，activation object</p>
<p><strong><em>4.作用域链 （Scope Chain）</em></strong></p>
<p>作用域（scope）:在JavaScript中，作用域是你可以访问的变量、对象、函数的集合。<br></div><a href="/2017/05/30/javascript中几个概念/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/05/30/undefined和null/" class="post-title-link">undefined和null</a></h2><div class="post-info">2017年5月30日</div><div class="post-content"><p>##undefined VS null</p>
<p>undeined表示一个变量已经被声明,但是还没有赋值。</p>
<p>null本身是一个值,可以被赋值给变量,代表‘空值’</p>
<p>undefined本身是一种类型(undefined),null是Object类型(typeof的结果,应该是bug,null也是js的基本类型之一)</p>
<p>js在创建变量时会给变量初始化为undefined,但是js从来不会将某个值初始化为null,必须手动设置为null</p></div><a href="/2017/05/30/undefined和null/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/05/22/top和left属性值问题/" class="post-title-link">top和left属性值问题</a></h2><div class="post-info">2017年5月22日</div><div class="post-content"><p>position为absoulate的元素，元素相对于盒子模型中的padding盒来进行定位。<br>为top、bottom、left、right等设置的值为百分比，进行计算时，top和bottom的值由padding盒的高度乘以百分比得到，left和right的值由padding盒的宽度乘以百分比得到。</p></div><a href="/2017/05/22/top和left属性值问题/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/05/16/javascript中的this/" class="post-title-link">javascript中的this</a></h2><div class="post-info">2017年5月16日</div><div class="post-content"><p>javascript中的<code>this</code>问题</p>
<p>javascript中的<code>this</code>对象取决于你如何调用函数：</p>
<p>通常来说有四种调用函数的方法：</p>
<p>1.<code>someThing.someFunction(arg1, arg2, argN)</code></p>
<p>2.<code>someFunction.call(someThing, arg1, arg2, argN)</code></p>
<p>3.<code>someFunction.apply(someThing, [arg1, arg2, argN])</code></p>
<p>上面三种调用方式，this对象都是<code>someThing</code></p>
<p>4.<code>new someFunction(arg1,arg2,argN)</code><br>使用<code>new</code>关键字，会创建一个Object对象，<code>this</code>是这个新建的对象</p></div><a href="/2017/05/16/javascript中的this/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/05/12/JS传递参数问题/" class="post-title-link">JS传递参数问题</a></h2><div class="post-info">2017年5月12日</div><div class="post-content"><p>关于js中函数传递参数时到底是传递值还是传递引用</p>
<p>参考下面代码:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeStuff</span>(<span class="params">a, b, c</span>)</span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  a = a * <span class="number">10</span>;</div><div class="line">  b.item = <span class="string">"changed"</span>;</div><div class="line">  c = &#123;<span class="attr">item</span>: <span class="string">"changed"</span>&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</div><div class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">item</span>: <span class="string">"unchanged"</span>&#125;;</div><div class="line"><span class="keyword">var</span> obj2 = &#123;<span class="attr">item</span>: <span class="string">"unchanged"</span>&#125;;</div><div class="line"></div><div class="line">changeStuff(num, obj1, obj2);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(num);</div><div class="line"><span class="built_in">console</span>.log(obj1.item);    </div><div class="line"><span class="built_in">console</span>.log(obj2.item);</div></pre></td></tr></table></figure></p>
<p>输出结果是:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">10</span></div><div class="line">changed</div><div class="line">unchanged</div></pre></td></tr></table></figure></p>
<p>如果js中全部都是按值传递，那么obj1.item应该不被改变。如果js中全部是按引用传递，那么obj2.item和num应该被改变。<br>实际上，<strong>js中所有的参数都是按值传递</strong>，只不过<strong>有些参数的值本身就是一个引用</strong>，如果改变参数本身的话（比如num和obj1)，不会对外部产生影响，如果改变参数内部属性的话，改变就会应用到函数外部，应用到引用所指向的内存中。</p></div><a href="/2017/05/12/JS传递参数问题/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/05/07/clear工作原理/" class="post-title-link">clear工作原理</a></h2><div class="post-info">2017年5月7日</div><div class="post-content"><p>对元素使用clear属性时，表示清除元素周围的浮动。</p>
<p>clear清除浮动时，<strong>对添加clear属性的元素本身起作用</strong>。比如:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="undefined">	div&#123;</span></div><div class="line"><span class="undefined">		width: 100px;</span></div><div class="line"><span class="undefined">		height: 100px;</span></div><div class="line"><span class="undefined">		background: red;</span></div><div class="line"><span class="undefined">		float: left;</span></div><div class="line"><span class="undefined">	&#125;</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"clear:both;"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></div><a href="/2017/05/07/clear工作原理/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/05/07/javaScript getter and setter/" class="post-title-link">JavaScript getter and setter</a></h2><div class="post-info">2017年5月7日</div><div class="post-content"><p>javaScript getter and setter</p>
<p>For the most part, in JavaScript, what you see is what you get. A value’s a value; there are no tricks. Sometimes however, you want a value that’s based on some other values: someone’s full name, for example, is a concatenation of their first and last names. If you have a person object, and you want the users of that object to be able to set the full, first or last name, and see that change immediately reflected in the other values, you’d conventionally build it with functions:</p></div><a href="/2017/05/07/javaScript getter and setter/" class="read-more">...阅读全文</a></article></li></ul></main><footer><div class="paginator"><a href="/" class="prev">上一页</a></div><div class="copyright"><p>© 2015 - 2017 <a href="https://stevens1995.github.io">Stevens</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://stevens1995.github.io/"/>
  <updated>2017-09-26T03:04:40.477Z</updated>
  <id>https://stevens1995.github.io/</id>
  
  <author>
    <name>Stevens</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTML5新特性总结</title>
    <link href="https://stevens1995.github.io/2017/09/26/HTML5%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    <id>https://stevens1995.github.io/2017/09/26/HTML5新特性总结/</id>
    <published>2017-09-26T03:04:40.000Z</published>
    <updated>2017-09-26T03:04:40.477Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSS3新特性总结</title>
    <link href="https://stevens1995.github.io/2017/09/26/CSS3%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    <id>https://stevens1995.github.io/2017/09/26/CSS3新特性总结/</id>
    <published>2017-09-26T03:04:00.000Z</published>
    <updated>2017-09-26T03:04:00.636Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ES6中的Iterator和generators</title>
    <link href="https://stevens1995.github.io/2017/09/25/ES6%E4%B8%AD%E7%9A%84Iterator%E5%92%8Cgenerators/"/>
    <id>https://stevens1995.github.io/2017/09/25/ES6中的Iterator和generators/</id>
    <published>2017-09-25T14:38:07.000Z</published>
    <updated>2017-09-25T15:11:32.860Z</updated>
    
    <content type="html"><![CDATA[<h4>什么是iterator</h4>

<p>iterator，迭代器，就是对象，具有一些用来迭代的接口。</p>
<p></p><h4>什么是generator</h4><br>generator是一个函数，返回一个iterator<p></p>
<p>在函数的function关键字之后，函数名之前加一个<code>*</code>号来表明函数是一个生成器。用<code>yield</code>关键字来声明返回值。迭代器和普通的for循环之间的区别是每次调用<code>next()</code>函数之后，不会继续执行，除非再次调用<code>next()</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;什么是iterator&lt;/h4&gt;

&lt;p&gt;iterator，迭代器，就是对象，具有一些用来迭代的接口。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;h4&gt;什么是generator&lt;/h4&gt;&lt;br&gt;generator是一个函数，返回一个iterator&lt;p&gt;&lt;/p&gt;
&lt;p&gt;在函数的functi
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ES6中的class</title>
    <link href="https://stevens1995.github.io/2017/09/25/ES6%E4%B8%AD%E7%9A%84class/"/>
    <id>https://stevens1995.github.io/2017/09/25/ES6中的class/</id>
    <published>2017-09-25T02:22:28.000Z</published>
    <updated>2017-09-25T14:44:31.935Z</updated>
    
    <content type="html"><![CDATA[<h4>ES5中的类结构实现:</h4>

<p>ES5中类似于类的实现是先创造一个构造函数，然后在其原型上定义方法，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">PersonType</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">PersonType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> PersonType(<span class="string">'Nicholas'</span>);</div><div class="line">person.sayName();   <span class="comment">// Nicholas</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> PersonType); <span class="comment">//true </span></div><div class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>上面这种模式是很多库实现类的基础，也是ES6中类的基础。  </p>
<h4>类声明</h4>

<p>class关键字 + 类名  花括号中的语法像是ES6中对象字面量中方法的简写，不过方法间没有逗号。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonClass</span></span>&#123;</div><div class="line">	<span class="comment">//定义类的构造函数</span></div><div class="line">	<span class="keyword">constructor</span>(name)&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	sayName()&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> PersonClass(<span class="string">'Nicholas'</span>);</div><div class="line">person.sayName();  <span class="comment">//Nicholas</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> PersonClass); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass); <span class="comment">//function</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass.prototype.sayName); <span class="comment">//function</span></div></pre></td></tr></table></figure>
<p>自有属性：对象的自有属性应该全部定义在构造函数中  </p>
<p>值得注意的是，class关键字声明只是基于现有的语法的语法糖，上面声明的PersonClass类实际上创造了一个函数，这个函数表现的和constructor构造函数一样。 所以<code>typeof PeronClass</code>是<code>function</code>，<code>sayName</code>函数和<code>constructor</code>的关系类似于上面<code>PersonType</code>和<code>sayName</code>的关系，这种类似性让我们在混合使用传统类型和ES6中的class时不需要有太多的顾虑。</p>
<p>虽然class和传统语法有类似，但也有一些很重要的区别:</p>
<ul><br>    <li>class定义不同于函数声明，不存在变量提升</li><br>    <li>class定义中自动使用严格模式</li><br>    <li>所有的方法都是不可枚举的</li><br>    <li>尝试使用<code>new</code>调用除构造函数之外的方法会报错</li><br>    <li>调用构造函数必须使用<code>new</code>关键字</li><br>    <li>尝试在类方法中修改类名会报错</li><br></ul>

<p>记住这些后，上面的类声明完全可以用下面的代码代替：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> PersonClass = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="meta">	'use strict'</span></div><div class="line">	<span class="keyword">const</span> PersonClass = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">		<span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">new</span>.target === <span class="string">'undefined'</span>)&#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Constructor must be called with new."</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">Object</span>.defineProperty(PersonType2.prototype,<span class="string">"sayName"</span>,&#123;</div><div class="line">		value:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">new</span>.target !== <span class="string">'undefined'</span>)&#123;</div><div class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Method cannot be call with new.'</span>);</div><div class="line">			&#125; </div><div class="line">			<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">		&#125;</div><div class="line">		enumerable:<span class="literal">false</span>,</div><div class="line">		writable:<span class="literal">true</span>,</div><div class="line">		configurable:<span class="literal">true</span></div><div class="line">	&#125;);</div><div class="line">	<span class="keyword">return</span> PersonClass;</div><div class="line">&#125;())</div></pre></td></tr></table></figure></p>
<p>通过let和const来保证不能从内部但是可以从外部改变类名，let同时也避免了class的变量提升，通过<code>new.target</code>来验证函数的调用是否应该使用<code>new</code>，通过<code>Object.defineProperty</code>来设置方法不可枚举。</p>
<h4>类表达式</h4>

<p>类有两种定义方式：类声明和类表达式，类似于函数声明和函数表达式，类声明的主要目的是为了将类作为一等公民传递到函数中。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;ES5中的类结构实现:&lt;/h4&gt;

&lt;p&gt;ES5中类似于类的实现是先创造一个构造函数，然后在其原型上定义方法，例如：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;d
    
    </summary>
    
    
      <category term="ES6" scheme="https://stevens1995.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>CSS揭秘</title>
    <link href="https://stevens1995.github.io/2017/09/14/CSS%E6%8F%AD%E7%A7%98/"/>
    <id>https://stevens1995.github.io/2017/09/14/CSS揭秘/</id>
    <published>2017-09-14T10:23:22.000Z</published>
    <updated>2017-09-15T01:03:22.588Z</updated>
    
    <content type="html"><![CDATA[<h4>1.半透明边框</h4>

<p>关键点：为元素设置背景颜色后，颜色会延伸至border的下面，所以当border为透明时看到的就是背景颜色<br>解决方法：border-clip:padding-box;</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;1.半透明边框&lt;/h4&gt;

&lt;p&gt;关键点：为元素设置背景颜色后，颜色会延伸至border的下面，所以当border为透明时看到的就是背景颜色&lt;br&gt;解决方法：border-clip:padding-box;&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ES6中的Symbol类型</title>
    <link href="https://stevens1995.github.io/2017/09/08/ES6%E4%B8%AD%E7%9A%84Symbol%E7%B1%BB%E5%9E%8B/"/>
    <id>https://stevens1995.github.io/2017/09/08/ES6中的Symbol类型/</id>
    <published>2017-09-08T01:14:00.000Z</published>
    <updated>2017-09-19T02:12:36.938Z</updated>
    
    <content type="html"><![CDATA[<h4>Symbols and Symbol properties</h4>

<p>Symbol 是继javaScript的 string、number、boolean、undefined、null之后的第六个基本类型，创建Symbol的初衷是为了建立对象的私有属性。</p>
<a id="more"></a>
<p>创建Symbol：</p>
<p>Symbol没有字面量形式，通过Symbol来创建一个新的Symbol，可以在函数中添加描述信息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">let</span> firstname = <span class="built_in">Symbol</span>(<span class="string">'firstname'</span>);</div><div class="line"><span class="keyword">let</span> person = &#123;&#125;;</div><div class="line"></div><div class="line">person[firstname] = <span class="string">"Stevens"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person[firstname]);</div></pre></td></tr></table></figure>
<p>共享Symbol:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> fir = <span class="built_in">Symbol</span>.for(<span class="string">'global'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> sec = <span class="built_in">Symbol</span>.for(<span class="string">'global'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(fir == sec);</div></pre></td></tr></table></figure>
<p>可以用Symbol.keyFor取回全局Symbol的关键字</p>
<p>关于Symbol的强制转换，Symbol不能转换为string或者number类型，所以下面的两行代码会报错：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> fir = <span class="built_in">Symbol</span>(<span class="string">'fir'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(fir+<span class="string">' '</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(fir/<span class="number">1</span>);</div></pre></td></tr></table></figure>
<p>读取对象的Symbol属性：</p>
<p>Object.keys和Object.getOwnPropertyNames()都不能获得Symbol属性，可通过Object.getOwnPropertySymbols()获取对象所有的Symbols属性</p>
<p>ES6对象中有关Symbol的操作和方法：</p>
<hr>
<p>Symbol.hasInstance - A method used by instanceof to determine an object’s inheritance.</p>
<p>Symbol.isConcatSpreadable - A Boolean value indicating that Array.prototype.concat() should flatten the collection’s elements if the collection is passed as a parameter to Array.prototype.concat().</p>
<p>Symbol.iterator - A method that returns an iterator.</p>
<p>Symbol.match - A method used by String.prototype.match() to compare strings.</p>
<p>Symbol.replace - A method used by String.prototype.replace() to replace substrings.</p>
<p>Symbol.search - A method used by String.prototype.search() to locate substrings.</p>
<p>Symbol.species - The constructor for making derived objects. </p>
<p>Symbol.split - A method used by String.prototype.split() to split up strings.</p>
<p>Symbol.toPrimitive - A method that returns a primitive valuerepresentation of an object.</p>
<p>Symbol.toStringTag - A string used by Object.prototype.toString() to create an object description.</p>
<p>Symbol.unscopables - An object whose properties are the names of object properties that should not be included in a with statement.</p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;Symbols and Symbol properties&lt;/h4&gt;

&lt;p&gt;Symbol 是继javaScript的 string、number、boolean、undefined、null之后的第六个基本类型，创建Symbol的初衷是为了建立对象的私有属性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ES6" scheme="https://stevens1995.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>Vue生命周期</title>
    <link href="https://stevens1995.github.io/2017/09/07/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://stevens1995.github.io/2017/09/07/Vue生命周期/</id>
    <published>2017-09-07T07:48:28.000Z</published>
    <updated>2017-09-07T08:57:34.020Z</updated>
    
    <content type="html"><![CDATA[<h4>Vue.js生命周期</h4>

<h4>Creation</h4>

<p>beforeCreate: 在Observe data和init Events之前，数据还不是响应式的，事件不存在。</p>
<p>created：在Observe data和init Events之后</p>
<h4>Mounting</h4>

<p>beforeMount: 在 template 和 render Function 被编译之前</p>
<p>mounted: 模板和渲染函数已经被编译，可以访问。</p>
<a id="more"></a>
<h4>Updating</h4>

<p>beforeUpdate: 数据已经被修改但是还没有被重新渲染</p>
<p>updated: template 和 DOM中的数据已经被修改后</p>
<h4>Destruction</h4>

<p>beforeDestory: Vue实例被销毁之前</p>
<p>destoryed: 实例已经被销毁，做一些最后的工作，比如向服务端发送消息。</p>
<p><img src="https://raw.githubusercontent.com/Stevens1995/blogImages/master/20170907/component-lifecycle.png" alt="Lifecycle" width="600" height="1300"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;Vue.js生命周期&lt;/h4&gt;

&lt;h4&gt;Creation&lt;/h4&gt;

&lt;p&gt;beforeCreate: 在Observe data和init Events之前，数据还不是响应式的，事件不存在。&lt;/p&gt;
&lt;p&gt;created：在Observe data和init Events之后&lt;/p&gt;
&lt;h4&gt;Mounting&lt;/h4&gt;

&lt;p&gt;beforeMount: 在 template 和 render Function 被编译之前&lt;/p&gt;
&lt;p&gt;mounted: 模板和渲染函数已经被编译，可以访问。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Vue.js" scheme="https://stevens1995.github.io/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>DOM相关(待总结和扩展)</title>
    <link href="https://stevens1995.github.io/2017/09/07/DOM%E7%9B%B8%E5%85%B3(%E5%BE%85%E6%80%BB%E7%BB%93%E5%92%8C%E6%89%A9%E5%B1%95)/"/>
    <id>https://stevens1995.github.io/2017/09/07/DOM相关(待总结和扩展)/</id>
    <published>2017-09-07T04:52:50.000Z</published>
    <updated>2017-09-08T08:45:43.807Z</updated>
    
    <content type="html"><![CDATA[<h4>Document Object Model</h4>

<p>DOM(document object model)是针对HTML和XML的一个API。DOM描述了一个层次化的节点树，允许开发人员添加、修改和删除节点。</p>
<p>Node类型：</p>
<p>DOM1级定义的Node类型接口，DOM中所有的节点都有实现这个接口。  </p>
<p>nodeType、nodeName、nodeValue</p>
<p>childNodes对象、parentNode、previousSibling、nextSibling</p>
<p>appendChild()、insertBefore()、replaceChild()、removeChild()</p>
<p>cloneNode()、normalize()</p>
<p>Document类型:</p>
<p>Document类型表示文档。浏览器中，document是HTMLDocument(继承自Document类型)的一个实例。</p>
<p>nodeType:9<br>nodeName:”#document”</p>
<p>document.documentElement表示第一个节点(html) 等于document.childNodes[0];</p>
<p>因为经常使用，document.body指向body节点</p>
<p>doctype:一般使用document.doctype取得对文档类型声明的引用  </p>
<p>不同浏览器有差异，有的将文档类型声明作为节点，可通过childNodes访问，有的不行，etc</p>
<p>document是HTMLDocument类型的一个实例，有一些Document类型没有的属性:</p>
<p>document.title、document.URL、document.domain、document.referrer</p>
<p>DOM一致性检测：</p>
<p>document.implementation()</p>
<p>文档写入：</p>
<p>document.write()、document.writeln、document.open()、document.close()</p>
<p>Element类型：</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;Document Object Model&lt;/h4&gt;

&lt;p&gt;DOM(document object model)是针对HTML和XML的一个API。DOM描述了一个层次化的节点树，允许开发人员添加、修改和删除节点。&lt;/p&gt;
&lt;p&gt;Node类型：&lt;/p&gt;
&lt;p&gt;DOM1级
    
    </summary>
    
    
      <category term="javascript" scheme="https://stevens1995.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>XSS和CSRF初步了解</title>
    <link href="https://stevens1995.github.io/2017/09/06/XSS%E5%92%8CCSRF%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3/"/>
    <id>https://stevens1995.github.io/2017/09/06/XSS和CSRF初步了解/</id>
    <published>2017-09-06T01:31:53.000Z</published>
    <updated>2017-09-06T02:35:34.728Z</updated>
    
    <content type="html"><![CDATA[<h4>XSS &amp; CSRF</h4>

<p>XSS:cross-site-scripting 跨站点脚本<br>CSRF:cross-site-request-forgery 跨站点请求伪造</p>
<p>XSS：攻击者不直接锁定要攻击的目标，通过向某些存在漏洞的网站（比如将用户输入不经过验证直接输出到网站）注入脚本，等到用户访问网站时，脚本运行从而达到攻击的目的。</p>
<p>存储型XSS:<br><img src="https://raw.githubusercontent.com/Stevens1995/blogImages/master/20170906/sorted-XSS.png" alt="XSS"></p>
<a id="more"></a>
<p>XSS的类型：</p>
<p>存储型（stored XSS）：又叫做持续型，注入的数据（被攻击者接收的数据）会存储在服务端，比如服务器。<br>反射型（reflected XSS）：用户的输入立即返回<br>基于DOM的XSS（DOM based XSS）：数据来源和数据接收的地方都是DOM，数据流不会离开客户端</p>
<p>防止XSS攻击：验证来自于客户端的数据或进行相关的处理</p>
<p>CSRF：攻击者通过已经通过验证，服务端完全信任的客户端（被攻击者）来发送http请求，从而达到攻击的目的</p>
<p><img src="https://raw.githubusercontent.com/Stevens1995/blogImages/master/20170906/csrf.png" alt="CSRF"></p>
<p>e.g. 攻击者向被攻击者发送一个图片 <code>&lt;img src=&quot;/attack?transferfund=4000&quot; alt=&quot;&quot;&gt;</code> 诱导被攻击者点击后，发送给服务器，服务器以为是经过认证的被攻击者发送的正常的请求，所以请求相映成功。</p>
<p>防止CSRF： 1.每次打开一个会话服务端向客户端发送一个唯一的不可预测的随机的数，每个正常的http请求都会隐蔽的带着这个随机数，从而让服务端能够判断是否是CSRF攻击请求<br>2.强制用户重新认证</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;XSS &amp;amp; CSRF&lt;/h4&gt;

&lt;p&gt;XSS:cross-site-scripting 跨站点脚本&lt;br&gt;CSRF:cross-site-request-forgery 跨站点请求伪造&lt;/p&gt;
&lt;p&gt;XSS：攻击者不直接锁定要攻击的目标，通过向某些存在漏洞的网站（比如将用户输入不经过验证直接输出到网站）注入脚本，等到用户访问网站时，脚本运行从而达到攻击的目的。&lt;/p&gt;
&lt;p&gt;存储型XSS:&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Stevens1995/blogImages/master/20170906/sorted-XSS.png&quot; alt=&quot;XSS&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="security" scheme="https://stevens1995.github.io/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>javascript事件模型</title>
    <link href="https://stevens1995.github.io/2017/09/05/javascript%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/"/>
    <id>https://stevens1995.github.io/2017/09/05/javascript事件模型/</id>
    <published>2017-09-05T01:01:11.000Z</published>
    <updated>2017-09-05T01:40:04.126Z</updated>
    
    <content type="html"><![CDATA[<h4>javascript事件模型</h4>


<h4>事件流：</h4>

<p>IE事件流：事件冒泡：事件最开始由具体的的元素接收，然后向上传播至不具体的节点。</p>
<p>Netscape: 事件捕获：不具体的的节点先接收到事件，具体的节点后接收到事件。</p>
<p>DOM事件流：事件捕获阶段、处于目标阶段、事件冒泡阶段。</p>
<a id="more"></a>
<h4>事件处理程序：</h4>

<p>HTML事件处理程序：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">onclick</span>=<span class="string">"alert('clicked.')"</span>&gt;</span></div></pre></td></tr></table></figure>
<p>this的值等于目标元素</p>
<p>DOM0级事件处理程序：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'mybtn'</span>);</div><div class="line"></div><div class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	alert(<span class="keyword">this</span>.id);</div><div class="line">&#125;</div><div class="line"></div><div class="line">btn.onclick = <span class="literal">null</span>;<span class="comment">//删除事件处理程序</span></div></pre></td></tr></table></figure>
<p>this指向目标元素</p>
<p>DOM2级事件处理程序：</p>
<p><code>addEventListener &amp; removeEventListener</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'mybtn'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	alert(<span class="keyword">this</span>.id);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">btn.addEventListener(<span class="string">'click'</span>,handle,<span class="literal">false</span>);<span class="comment">//true表示在事件捕获阶段处理程序，fasle表示在事件冒泡阶段处理程序</span></div><div class="line"></div><div class="line">btn.addEventListener(<span class="string">'click'</span>,handle,<span class="literal">true</span>);<span class="comment">//可以在事件捕获阶段再定义处理程序，与冒泡阶段互不影响，移除的时候也要分别移除</span></div><div class="line"></div><div class="line"></div><div class="line">btn.addEventListener(<span class="string">'click'</span>,handle2,<span class="literal">false</span>);</div><div class="line"></div><div class="line"><span class="comment">//可以添加多个事件处理程序，按照定义的顺序执行</span></div><div class="line"></div><div class="line"></div><div class="line">btn.removeEventListener(<span class="string">'click'</span>,handle,<span class="literal">false</span>);</div></pre></td></tr></table></figure>
<p>IE事件处理程序：</p>
<p><code>attachEvent &amp; detachEvent</code></p>
<p>通过attach添加的时间处理程序只会在冒泡阶段发生。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'mybtn'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</div><div class="line">&#125;</div><div class="line"></div><div class="line">btn.attachEvent(<span class="string">'onclick'</span>,handle);<span class="comment">//与DOM2不同的是这里添加的是时间处理程序的名称不是事件名称</span></div><div class="line"></div><div class="line">btn.detachEvent(<span class="string">'onclick'</span>,handle);</div></pre></td></tr></table></figure>
<h4>跨浏览器处理程序：</h4>

<p>检测对应的对象是否存在然后决定使用哪个，注意检测顺序：DOM2 -&gt; IE -&gt;HTML事件处理程序</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;javascript事件模型&lt;/h4&gt;


&lt;h4&gt;事件流：&lt;/h4&gt;

&lt;p&gt;IE事件流：事件冒泡：事件最开始由具体的的元素接收，然后向上传播至不具体的节点。&lt;/p&gt;
&lt;p&gt;Netscape: 事件捕获：不具体的的节点先接收到事件，具体的节点后接收到事件。&lt;/p&gt;
&lt;p&gt;DOM事件流：事件捕获阶段、处于目标阶段、事件冒泡阶段。&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript事件模型" scheme="https://stevens1995.github.io/tags/javascript%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>TCP三次握手四次挥手</title>
    <link href="https://stevens1995.github.io/2017/09/04/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>https://stevens1995.github.io/2017/09/04/TCP三次握手四次挥手/</id>
    <published>2017-09-04T06:32:25.000Z</published>
    <updated>2017-09-08T04:35:24.827Z</updated>
    
    <content type="html"><![CDATA[<h4>TCP三次握手四次挥手</h4>


<h4>three handshake:</h4>


<p><img src="https://raw.githubusercontent.com/Stevens1995/blogImages/master/20170904/handshake.png" alt="tcp_handshake"></p>
<a id="more"></a>
<p>1.首先客户端的TCP首先向服务端发送一个特殊的TCP报文段，报文段首部的SYN标志位被置为1，另外，客户端会随机地选择一个初始序号(seq)，并将此编号放置于该报文段的序号字段中，随后报文被封装到一个IP数据报中并发送给服务器</p>
<p>2.服务器提取出TCP报文段,为该TCP连接分配TCP缓存和变量，并想该客户端TCP发送允许连接的报文段。报文段的SYN标志位置为1，首部确认号字段被置为seq+1，最后服务端选择自己的初始序列号seq。</p>
<p>3.客户端TCP收到服务端允许连接的报文段后，客户端也要为该连接分配缓存和变量。客户端再向服务器发送确认报文段，序号seq为之前的序号加一，确认字段ACK为seq_server加一，最后一部SYN置为0，连接建立。</p>
<h4>four waved:</h4>



<p><img src="https://raw.githubusercontent.com/Stevens1995/blogImages/master/20170904/waved.png" alt=""></p>
<p>一个TCP连接中的双方都能终止连接，比如客户端要终止连接，客户端即发送TCP报文段，FIN标志位置为1，服务端收到后发送一个确认报文段，客户端联机即终止。服务端要终止的话也要进行相同的操作。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;TCP三次握手四次挥手&lt;/h4&gt;


&lt;h4&gt;three handshake:&lt;/h4&gt;


&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Stevens1995/blogImages/master/20170904/handshake.png&quot; alt=&quot;tcp_handshake&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>事件委托</title>
    <link href="https://stevens1995.github.io/2017/09/04/%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/"/>
    <id>https://stevens1995.github.io/2017/09/04/事件委托/</id>
    <published>2017-09-04T03:22:56.000Z</published>
    <updated>2017-09-06T11:34:33.278Z</updated>
    
    <content type="html"><![CDATA[<h4>javascript delegation(事件委托)</h4>

<p>事件委托能够避免在js中为很多具体的节点添加事件监听，只需为父元素添加即可。通过父元素的事件监听来分析事件冒泡从而获得匹配的子元素。</p>
<a id="more"></a>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"parent-list"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"post-1"</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"post-2"</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"post-3"</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"post-4"</span>&gt;</span>Item 4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"post-5"</span>&gt;</span>Item 5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"post-6"</span>&gt;</span>Item 6<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// Get the element, add a click listener...</span></div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">"parent-list"</span>).addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">	<span class="comment">// e.target is the clicked element!</span></div><div class="line">	<span class="comment">// If it was a list item</span></div><div class="line">	<span class="keyword">if</span>(e.target &amp;&amp; e.target.nodeName == <span class="string">"LI"</span>) &#123;</div><div class="line">		<span class="comment">// List item found!  Output the ID!</span></div><div class="line">		<span class="built_in">console</span>.log(<span class="string">"List item "</span>, e.target.id.replace(<span class="string">"post-"</span>, <span class="string">""</span>), <span class="string">" was clicked!"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;javascript delegation(事件委托)&lt;/h4&gt;

&lt;p&gt;事件委托能够避免在js中为很多具体的节点添加事件监听，只需为父元素添加即可。通过父元素的事件监听来分析事件冒泡从而获得匹配的子元素。&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="https://stevens1995.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Grid详解</title>
    <link href="https://stevens1995.github.io/2017/08/31/Grid%E8%AF%A6%E8%A7%A3/"/>
    <id>https://stevens1995.github.io/2017/08/31/Grid详解/</id>
    <published>2017-08-31T10:02:20.000Z</published>
    <updated>2017-09-19T02:20:51.556Z</updated>
    
    <content type="html"><![CDATA[<h4>Grid详解</h4>

<h4>容器属性:</h4>

<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#container</span>&#123;</div><div class="line">	<span class="attribute">display</span>: grid | inline-grid | subgrid; <span class="comment">/* 定义一个grid容器*/</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#container</span>&#123;</div><div class="line">	<span class="attribute">grid-template-columns</span>:;   <span class="comment">/*定义容器的列*/</span></div><div class="line">	<span class="attribute">grid-template-rows</span>:;  <span class="comment">/*定义容器的行*/</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#container</span>&#123;</div><div class="line">	<span class="attribute">grid-template-areas</span>: ; </div><div class="line">	<span class="comment">/*划分容器的区域,分别为每个单元分配单元属于哪个部分,指定之后便可以在子项目中用grid-area来占用这个区域*/</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#container</span>&#123;</div><div class="line">	<span class="attribute">grid-column-gap</span>:; </div><div class="line">	<span class="attribute">grid-row-gap</span>:;</div><div class="line">	<span class="comment">/*定义track间线的宽度*/</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#container</span>&#123;</div><div class="line">	<span class="attribute">justify-content</span>: ; <span class="comment">/*定义容器的剩余空间如何排列*/</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;Grid详解&lt;/h4&gt;

&lt;h4&gt;容器属性:&lt;/h4&gt;

&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;
    
    </summary>
    
    
      <category term="css" scheme="https://stevens1995.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Flex详解</title>
    <link href="https://stevens1995.github.io/2017/08/30/Flex%E8%AF%A6%E8%A7%A3/"/>
    <id>https://stevens1995.github.io/2017/08/30/Flex详解/</id>
    <published>2017-08-30T06:26:22.000Z</published>
    <updated>2017-09-19T02:05:22.226Z</updated>
    
    <content type="html"><![CDATA[<h4>Flex详解</h4>

<h4>总览:</h4>

<p><img src="https://raw.githubusercontent.com/Stevens1995/blogImages/master/20170830/flexbox.png" alt="flex总览"></p>
<a id="more"></a>
<h4>Flex container属性:</h4>

<p><code>display:flex:</code>定义一个Flex容器</p>
<p><code>flex-direction:</code> 建立主轴，定义项目在主轴上的排列方向 </p>
<p>row | row-reverse | column | column-reverse<br>row(默认):主轴水平方向，项目从左到右排列<br>row-reverse:主轴水平，项目从右到左<br>column:主轴垂直，项目从上到下<br>column-reverse:主轴垂直，项目从下到上</p>
<p><code>flex-wrap:</code>默认的所有项目在主轴上排列，不换行，可通过flex-wrap来改变  </p>
<p><code>nowrap | wrap | wrap-reverse</code></p>
<p>nowrap(默认):所有项目排列在主轴上不换行<br>wrap:换行，项目从顶部到底部<br>wrap-reverse:不换行，项目从底部到顶部</p>
<p><code>flex-flow:</code> flex-direction 和 flex-wrap的简写</p>
<p>flex-flow: &lt;’flex-direction’&gt; || &lt;’felx-wrap’&gt;</p>
<p><code>justify-content:</code>定义项目在主轴上的排列</p>
<p><code>flex-start | flex-end | center | space-between | space-around | space-evenly</code></p>
<p>flex-start(默认):项目从主轴开始的地方开始排列<br>flex-end:从主轴结束的地方开始排列<br>center:项目排列在主轴中间<br>space-between:项目均匀分布在主轴上，第一个在开始线，最后一个在结束线，中间的项目均匀分布<br>space-around:每个项目左边和右边的空隙一样(注意，中间的间隔是左右间隔的两倍)<br>space-evenly:项目间的间隔一样(所有间隔都一样)</p>
<p><code>align-items:</code>项目在交叉轴上的布局</p>
<p><code>flex-start | flex-end | center | stretch | baseline</code></p>
<p>flex-start:项目在交叉轴的边缘从交叉轴的开始处开始<br>flex-end:项目在交叉轴的边缘从交叉轴的结束处开始<br>center:f项目处在交叉轴中间<br>baseline:项目根据基线对齐<br>stretch:伸展填充container  </p>
<p><code>align-content:</code>排列 主轴上的行 在交叉轴上的空间 (当主轴只有一行时这个属性不起作用)</p>
<p><code>flex-start | flex-end | center | space-between | space-around | stretch</code></p>
<p>flex-start:行从交叉轴开始的地方排列<br>flex-end:行从交叉轴结束的地方开始排列<br>center:行在交叉轴的中间<br>space-between:行之间的间隔相等，第一行在交叉轴开始线处，最后一行在交叉轴结束线处<br>space-around:每行左右间距相同<br>stretch:行伸展以填充container</p>
<h4>Flex items属性:</h4>

<p><code>order:</code>定义项目排列的顺序</p>
<p>order:<integer></integer></p>
<p><code>flex-grow:</code>:定义项目扩大的能力，接收一个没有单位的值代表比例，决定占据多少主轴上剩余的可用空间  </p>
<p><code>flex-shrink:</code>定义项目缩小的能力(负值无效)  </p>
<p><code>flex-basis:</code>定义在分配剩余空间之前项目的默认大小</p>
<p><code>flex:</code>前面三个属性的简写</p>
<p>flex: flex-grow || flex-shrink || flex-basis</p>
<p><code>align-self:</code>定义个别项目在交叉轴上排列方式，这可以覆盖在container上定义的align-item属性</p>
<p><code>flex-start | flex-end</code></p>
<p>flex-start:从交叉轴的开始线处开始排列<br>flex-end:从交叉轴的结束线处开始排列</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;Flex详解&lt;/h4&gt;

&lt;h4&gt;总览:&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Stevens1995/blogImages/master/20170830/flexbox.png&quot; alt=&quot;flex总览&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="CSS" scheme="https://stevens1995.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>slice &amp; splice</title>
    <link href="https://stevens1995.github.io/2017/08/22/sliceandsplice/"/>
    <id>https://stevens1995.github.io/2017/08/22/sliceandsplice/</id>
    <published>2017-08-22T11:30:36.000Z</published>
    <updated>2017-08-28T14:16:26.989Z</updated>
    
    <content type="html"><![CDATA[<h4>Array.prototype.slice &amp; Array.prototype.splice</h4>

<p>Array.prototype.slice 返回从开始索引到结束索引的数组(不包括结束)，不改变原数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line">a.slice(<span class="number">0</span>,<span class="number">2</span>);<span class="comment">//[1,2]</span></div></pre></td></tr></table></figure>
<p>Array.prototype.splce 从开始索引删除指定个数的元素(包括开始)，改变原数组，返回删除的元素组成的数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line">a.splice(<span class="number">0</span>,<span class="number">2</span>);<span class="comment">// [1,2]</span></div><div class="line">a <span class="comment">//[3,4,5]</span></div></pre></td></tr></table></figure>
<a id="more"></a>
]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;Array.prototype.slice &amp;amp; Array.prototype.splice&lt;/h4&gt;

&lt;p&gt;Array.prototype.slice 返回从开始索引到结束索引的数组(不包括结束)，不改变原数组&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;a.slice(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//[1,2]&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Array.prototype.splce 从开始索引删除指定个数的元素(包括开始)，改变原数组，返回删除的元素组成的数组&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;a.splice(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;// [1,2]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;a &lt;span class=&quot;comment&quot;&gt;//[3,4,5]&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://stevens1995.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://stevens1995.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>sass</title>
    <link href="https://stevens1995.github.io/2017/08/21/sass/"/>
    <id>https://stevens1995.github.io/2017/08/21/sass/</id>
    <published>2017-08-21T15:16:47.000Z</published>
    <updated>2017-08-22T12:16:20.214Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="css" scheme="https://stevens1995.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://stevens1995.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>FunctionalPrograming</title>
    <link href="https://stevens1995.github.io/2017/08/19/FunctionalPrograming/"/>
    <id>https://stevens1995.github.io/2017/08/19/FunctionalPrograming/</id>
    <published>2017-08-19T09:08:07.000Z</published>
    <updated>2017-09-04T07:13:25.925Z</updated>
    
    <content type="html"><![CDATA[<h4>Functional Programing(函数式编程)</h4>


<p>函数式编程(Functional Programing、FP)通过构建纯函数来编程，避免了状态共享(shared state)、可变的数据(mutable data)、副作用(side-effects)。函数式编程是声明式(declarative)而不是命令式(imperative)的编程。</p>
<p>函数式编程是一种编程方法、模式，类同于面向对象编程、过程式编程。</p>
<a id="more"></a>
<h5>掌握函数式编程需要理解的几个概念：</h5>

<p>纯函数(pure function)、函数组合(function composition)、避免共享状态(avoid shared state)、避免突变状态(avoid mutation state)、避免副作用(avoid side-effects)</p>
<h6>纯函数是拥有以下特性的函数：</h6>  

<p>1.相同的输入对应相同的输出<br>2.没有副作用</p>
<p>并且，纯函数有许多对函数式编程来说很重要的特性，比如引用透明性(referential transparency，指可以用函数的返回值替代函数而不对代码的含义产生影响)</p>
<h6>函数组合：</h6><br>将多个函数组合起来以产生一个新的函数或者执行某些计算，e.g.f(g(x))<br><br><h6>共享状态(shared state)：</h6><br>共享状态可以包含以下情形：共享作用域中的变量、对象或者内存空间，在多个作用域中传递的对象的属性<br><br>共享状态的弊端：<br>1.改变函数的执行顺序和时间会产生一些不同的结果<br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> x = &#123;</div><div class="line">	val:<span class="number">2</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> x1 = <span class="function"><span class="params">()</span>=&gt;</span>x.val+=<span class="number">1</span>;</div><div class="line"><span class="keyword">const</span> x2 = <span class="function"><span class="params">()</span>=&gt;</span>x.val*=<span class="number">2</span>;</div><div class="line"></div><div class="line">x1();</div><div class="line">x2(); </div><div class="line"><span class="built_in">console</span>.log(x.val); <span class="comment">//6</span></div><div class="line"></div><div class="line"><span class="comment">//another order</span></div><div class="line">x2();</div><div class="line">x1();</div><div class="line"><span class="built_in">console</span>.log(x.val)<span class="comment">//5</span></div></pre></td></tr></table></figure><br><br>避免了共享状态后，函数的顺序不会影响执行结果：<br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> y = &#123;</div><div class="line">	val:<span class="number">2</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> y1 = <span class="function"><span class="params">y</span>=&gt;</span><span class="built_in">Object</span>.assign(&#123;&#125;,y,&#123; <span class="attr">val</span>:x.val+<span class="number">1</span>&#125;);</div><div class="line"><span class="keyword">const</span> y2 = <span class="function"><span class="params">y</span>=&gt;</span><span class="built_in">Object</span>.assign(&#123;&#125;,y,&#123; <span class="attr">val</span>:x.val*<span class="number">2</span>&#125;);</div><div class="line"></div><div class="line"><span class="comment">//在此你可以执行任意的代码，而不会影响到后面的输出，因为函数不依赖于后面执行函数的依赖的状态</span></div><div class="line">y1();</div><div class="line">y2();</div><div class="line"></div><div class="line"><span class="comment">//或者</span></div><div class="line">y2();</div><div class="line">y1();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(y1(y2(y).val));</div></pre></td></tr></table></figure><br><br><h6>永恒性(immutability):</h6>

<p>不能通过const来定义不可变的对象，const只是指定变量的引用的对象不能改变，可以改变对象的属性。</p>
<p>Object.freeze()方法也不能完全是对象不可变，比如对象中又有对象，除非使用Object.freeze()方法来封住每一层的对象。</p>
<h6>副作用：</h6>

<p>在函数式编程中，副作用指的是任何在调用的函数之外可以检测到的应用程序状态的改变。</p>
<h5>通过高阶函数的可重用性(reusability though high order function)：</h5>

<h5></h5>
]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;Functional Programing(函数式编程)&lt;/h4&gt;


&lt;p&gt;函数式编程(Functional Programing、FP)通过构建纯函数来编程，避免了状态共享(shared state)、可变的数据(mutable data)、副作用(side-effects)。函数式编程是声明式(declarative)而不是命令式(imperative)的编程。&lt;/p&gt;
&lt;p&gt;函数式编程是一种编程方法、模式，类同于面向对象编程、过程式编程。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://stevens1995.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://stevens1995.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Flex</title>
    <link href="https://stevens1995.github.io/2017/08/16/Flex/"/>
    <id>https://stevens1995.github.io/2017/08/16/Flex/</id>
    <published>2017-08-16T11:39:48.000Z</published>
    <updated>2017-09-04T07:13:27.500Z</updated>
    
    <content type="html"><![CDATA[<h4>Flex中关于flex-grow与flex-shrink的计算</h4>

<p>Flex容器中的项目<code>Flex</code>属性简写</p>
<p><code>flex:1 0 150px;</code><br>这个简写能被拆分成三个属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">flex-grow:<span class="number">1</span>;</div><div class="line"></div><div class="line">flex-shrink:<span class="number">0</span>;</div><div class="line"></div><div class="line">felx-basis:<span class="number">150</span>px;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h5>flex-grow</h5>

<p>定义容器中项目的增长，当容器空间有剩余时，计算方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">增长的长度 = 剩余空间 × (某个项目的flex-grow属性值/所有项目flex-grow属性值的和)</div></pre></td></tr></table></figure>
<h5>flex-shrink</h5>

<p>定义容器中项目的收缩，当容器空间不够时，计算方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">总和 = 每个项目的flex-shrink的值 × 项目的flex-basis值</div><div class="line"></div><div class="line">项目缩小的长度 = 超过的空间 × (每个项目的flex-shrink的值×项目的flex-basis)</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;Flex中关于flex-grow与flex-shrink的计算&lt;/h4&gt;

&lt;p&gt;Flex容器中的项目&lt;code&gt;Flex&lt;/code&gt;属性简写&lt;/p&gt;
&lt;p&gt;&lt;code&gt;flex:1 0 150px;&lt;/code&gt;&lt;br&gt;这个简写能被拆分成三个属性：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;flex-grow:&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;flex-shrink:&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;felx-basis:&lt;span class=&quot;number&quot;&gt;150&lt;/span&gt;px;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="css" scheme="https://stevens1995.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://stevens1995.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>CommonJS vs AMD vs ES2015module</title>
    <link href="https://stevens1995.github.io/2017/06/03/CommonJSvsAMDvsES2015module/"/>
    <id>https://stevens1995.github.io/2017/06/03/CommonJSvsAMDvsES2015module/</id>
    <published>2017-06-03T09:56:41.000Z</published>
    <updated>2017-08-28T14:07:17.663Z</updated>
    
    <content type="html"><![CDATA[<h4>常见的JavaScript模块系统总结，不同标准的特点以及区别。</h4>

<p>参考并翻译此文章: <a href="https://auth0.com/blog/javascript-module-systems-showdown/" target="_blank" rel="external">https://auth0.com/blog/javascript-module-systems-showdown/</a></p>
<p><strong><em>COMMONJS:</em></strong></p>
<p>CommonJS致力于定义一系列的规范来帮助进行服务端的JavaScript开发。其中一个CommonJS尝试解决的领</p>
<p>域就是模块化。Node.js开发者最初打算遵循CommonJS规范，但是后来决定放弃。但是node.js的实现很大</p>
<p>程度上受到了CommonJS的影响。（也就是说node.js并没有完全遵循CommonJS规范）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In circle.js</span></div><div class="line"><span class="keyword">const</span> PI = <span class="built_in">Math</span>.PI;</div><div class="line"></div><div class="line">exports.area = <span class="function">(<span class="params">r</span>) =&gt;</span> PI * r * r;</div><div class="line"></div><div class="line">exports.circumference = <span class="function">(<span class="params">r</span>) =&gt;</span> <span class="number">2</span> * PI * r;</div><div class="line"></div><div class="line"><span class="comment">// In some file</span></div><div class="line"><span class="keyword">const</span> circle = <span class="built_in">require</span>(<span class="string">'./circle.js'</span>);</div><div class="line"><span class="built_in">console</span>.log( <span class="string">`The area of a circle of radius 4 is <span class="subst">$&#123;circle.area(<span class="number">4</span>)&#125;</span>`</span>);</div></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>“Forget CommonJS. It’s dead. We are server side JavaScript.” - NPM creator Isaac Z. Schlueter quoting Node.js creator Ryan Dahl</strong> </p>
<p>在Node.js中，模块系统抽象为库的形式，这减小了Node.js和CommonJS的差异。在这片文章中我们只谈论一些</p>
<p>在二者中大致相同的功能。</p>
<p>在Node.js和CommonJS中，本质上都是用两个对象来和模块系统进行交换：<code>require</code>和<code>exports</code>。</p>
<p><code>require</code>是一个函数，用来将其他模块导入到当前作用域。传递给<code>require</code>的参数时模块的id。</p>
<p>在node.js中，是在<code>node_modules</code>文件夹下的模块名。（如果不是，也可以传递文件的路径）<code>exports</code></p>
<p>是一个特殊的对象，任何传递到其中的对象或者变量将会作为公共元素导出。Node和CommonJS一个奇特的区别在于</p>
<p><code>module.exports</code>对象。在Node中，<code>module.exports</code>是一个特殊的会被导出的对象，<code>exports</code>是一个默认绑定到</p>
<p><code>module.exports</code>的变量。CommonJS中则没有<code>module.exports</code>对象。这在实际应用中体现在，</p>
<p>Node必须通过<code>module.exports</code>导出一个对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// This won't work, replacing exports entirely breaks the binding to</span></div><div class="line"><span class="comment">// modules.exports.</span></div><div class="line">exports =  <span class="function">(<span class="params">width</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    area: <span class="function"><span class="params">()</span> =&gt;</span> width * width</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// This works as expected.</span></div><div class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">width</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    area: <span class="function"><span class="params">()</span> =&gt;</span> width * width</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>CommonJS模块是为服务端开发进行设计。API是同步的，换句话说，模块按照他们在文件中<code>require</code>的时间和顺序进行加载。</p>
<p><strong>CommonJS modules were designed with serve development in mind.</strong></p>
<p>优点：</p>
<p>1.简单：开发者能够轻易理解。</p>
<p>2.依赖管理集成：模块可以<code>require</code>其他模块并且按需要加载。</p>
<p>3.<code>require</code>可以在任何地方被调用：模块可以以编程的方式加载。</p>
<p>4.支持循环依赖</p>
<p>缺点：</p>
<p>1.同步的API使他不适合某些用途。（客户端）。</p>
<p>2.一个模块一个文件</p>
<p>3.Browsers require a loader library or transpiling.</p>
<p>4.没有模块的构造函数 (Node支持).</p>
<p>5.Hard to analyze for static code analyzers.</p>
<p>CommonJS的实现: <code>Node.js</code></p>
<p><br><br><br><br><strong>AMD(Asynchronous Module Definition):</strong></p>
<p>AMD出自一群对CommonJS采用的方向感到不满的开发者。事实上，AMD was split from CommonJS early in its development。</p>
<p>AMD与CommonJS的不同之处在于AMD对于模块异步加载的支持。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Calling define with a dependency array and a factory function</span></div><div class="line">define([<span class="string">'dep1'</span>, <span class="string">'dep2'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">dep1, dep2</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//Define the module value by returning a value.</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// Or:</span></div><div class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> dep1 = <span class="built_in">require</span>(<span class="string">'dep1'</span>),</div><div class="line">        dep2 = <span class="built_in">require</span>(<span class="string">'dep2'</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>使用javascript传统闭包的用法让异步加载成为可能:在请求的模块加载完成时调用回调函数。</p>
<p>模块的定义和模块的导入由同一个函数承载。当一个模块被定义，他的依赖就明确下来。因此，</p>
<p>AMD加载器在运行时拥有给定项目的完整的依赖图。 没有依赖关系的模块就能够同时加载。这</p>
<p>对于浏览器来说尤其重要，启动时间对于用户体验至关重要。</p>
<p>优点：<br>1.异步加载(更快的启动时间)</p>
<p>2.支持循环依赖</p>
<p>3.Dependency management fully integrated.</p>
<p>4.兼容<code>require</code>和<code>exports</code></p>
<p>5.如果需要的话一个模块可以分到多个文件中。</p>
<p>6.支持构造函数。</p>
<p>7.插件支持。（自定义加载步骤）</p>
<p>缺点：<br>1.略微复杂的语法</p>
<p>2.Loader libraries are required unless transpiled.</p>
<p>3.Hard to analyze for static code analyzers.</p>
<p>AMD实现：目前比较受欢迎的实现由<code>Require.js</code>和<code>Dojo</code></p>
<p><br><br><br><br><strong>ES2015：</strong></p>
<p>幸运的是，JavaScript背后负责标准化的ECMA团队决定处理模块问题。</p>
<p>解决的结果能在最近发布的JavaScript标准中看到：ECMAScript2015（ECMAScript6）</p>
<p>结果在语法上更令人愉悦，并且兼容同步和异步模式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//------ lib.js ------</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> sqrt = <span class="built_in">Math</span>.sqrt;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x * x;</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">diag</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> sqrt(square(x) + square(y));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//------ main.js ------</span></div><div class="line"><span class="keyword">import</span> &#123; square, diag &#125; <span class="keyword">from</span> <span class="string">'lib'</span>;</div><div class="line"><span class="built_in">console</span>.log(square(<span class="number">11</span>)); <span class="comment">// 121</span></div><div class="line"><span class="built_in">console</span>.log(diag(<span class="number">4</span>, <span class="number">3</span>)); <span class="comment">// 5</span></div></pre></td></tr></table></figure>
<p><code>import</code>能用于将模块引入命名空间，<code>import</code>指令与<code>require</code>和<code>define</code>指令对比</p>
<p>来说不是动态的。（也就是说不能在所有地方调用）。<code>export</code>指令能够明确地将公开</p>
<p>元素</p>
<p><code>import</code>和<code>export</code>指令的静态特性允许静态分析器构建完整的依赖关系树，而不运行代码。</p>
<p><strong>最新ECMAScript标准支持动态加载模块，这是ECMAScript标准未来发布版本的提案。</strong></p>
<p>ES2015实现：目前木有。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;常见的JavaScript模块系统总结，不同标准的特点以及区别。&lt;/h4&gt;

&lt;p&gt;参考并翻译此文章: &lt;a href=&quot;https://auth0.com/blog/javascript-module-systems-showdown/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://auth0.com/blog/javascript-module-systems-showdown/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;COMMONJS:&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CommonJS致力于定义一系列的规范来帮助进行服务端的JavaScript开发。其中一个CommonJS尝试解决的领&lt;/p&gt;
&lt;p&gt;域就是模块化。Node.js开发者最初打算遵循CommonJS规范，但是后来决定放弃。但是node.js的实现很大&lt;/p&gt;
&lt;p&gt;程度上受到了CommonJS的影响。（也就是说node.js并没有完全遵循CommonJS规范）。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// In circle.js&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; PI = &lt;span class=&quot;built_in&quot;&gt;Math&lt;/span&gt;.PI;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;exports.area = &lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;r&lt;/span&gt;) =&amp;gt;&lt;/span&gt; PI * r * r;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;exports.circumference = &lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;r&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; * PI * r;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// In some file&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; circle = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;./circle.js&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log( &lt;span class=&quot;string&quot;&gt;`The area of a circle of radius 4 is &lt;span class=&quot;subst&quot;&gt;$&amp;#123;circle.area(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)&amp;#125;&lt;/span&gt;`&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="programing" scheme="https://stevens1995.github.io/categories/programing/"/>
    
    
      <category term="programing" scheme="https://stevens1995.github.io/tags/programing/"/>
    
  </entry>
  
  <entry>
    <title>javascript中几个概念</title>
    <link href="https://stevens1995.github.io/2017/05/30/javascript%E4%B8%AD%E5%87%A0%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    <id>https://stevens1995.github.io/2017/05/30/javascript中几个概念/</id>
    <published>2017-05-30T08:28:50.000Z</published>
    <updated>2017-08-28T14:15:43.531Z</updated>
    
    <content type="html"><![CDATA[<p>关于javascript中几个概念的解释:</p>
<p><strong><em>1.执行上下文（Execution Context）</em></strong></p>
<p>通俗来说就是函数执行时的环境，包括下面几个部分： </p>
<p>变量对象、作用域链、this</p>
<p><strong><em>2.活动对象（Activation Object）</em></strong></p>
<p>形参、arguments对象、函数中定义的变量和函数</p>
<p><strong><em>3.变量对象（Variable Object）</em></strong></p>
<p>在全局上下文中，global object</p>
<p>在函数中，activation object</p>
<p><strong><em>4.作用域链 （Scope Chain）</em></strong></p>
<p>作用域（scope）:在JavaScript中，作用域是你可以访问的变量、对象、函数的集合。<br><a id="more"></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于javascript中几个概念的解释:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;1.执行上下文（Execution Context）&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通俗来说就是函数执行时的环境，包括下面几个部分： &lt;/p&gt;
&lt;p&gt;变量对象、作用域链、this&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.活动对象（Activation Object）&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;形参、arguments对象、函数中定义的变量和函数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;3.变量对象（Variable Object）&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在全局上下文中，global object&lt;/p&gt;
&lt;p&gt;在函数中，activation object&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;4.作用域链 （Scope Chain）&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作用域（scope）:在JavaScript中，作用域是你可以访问的变量、对象、函数的集合。&lt;br&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://stevens1995.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://stevens1995.github.io/tags/javascript/"/>
    
  </entry>
  
</feed>

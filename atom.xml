<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://stevens1995.github.io/"/>
  <updated>2017-09-07T08:53:53.680Z</updated>
  <id>https://stevens1995.github.io/</id>
  
  <author>
    <name>Stevens</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue生命周期</title>
    <link href="https://stevens1995.github.io/2017/09/07/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://stevens1995.github.io/2017/09/07/Vue生命周期/</id>
    <published>2017-09-07T07:48:28.000Z</published>
    <updated>2017-09-07T08:53:53.680Z</updated>
    
    <content type="html"><![CDATA[<h4>Vue.js生命周期</h4>

<p><img src="https://raw.githubusercontent.com/Stevens1995/blogImages/master/20170907/component-lifecycle.png" alt="Lifecycle" width="600" height="1400"></p>
<a id="more"></a>
<h4>Creation</h4>

<p>beforeCreate: 在Observe data和init Events之前，数据还不是响应式的，事件不存在。</p>
<p>created：在Observe data和init Events之后</p>
<h4>Mounting</h4>

<p>beforeMount: 在 template 和 render Function 被编译之前</p>
<p>mounted: 在这个钩子中，响应式数据、模板、render Function都可用</p>
<h4>Updating</h4>

<p>beforeUpdate: 数据已经被修改但是还没有被重新渲染</p>
<p>updated: template 和 DOM中的数据已经被修改后</p>
<h4>Destruction</h4>

<p>beforeDestory: Vue实例被销毁之前</p>
<p>destoryed: 实例已经被销毁，做一些最后的工作，比如向服务端发送消息。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;Vue.js生命周期&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Stevens1995/blogImages/master/20170907/component-lifecycle.png&quot; alt=&quot;Lifecycle&quot; width=&quot;600&quot; height=&quot;1400&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Vue.js" scheme="https://stevens1995.github.io/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>DOM相关</title>
    <link href="https://stevens1995.github.io/2017/09/07/DOM%E7%9B%B8%E5%85%B3/"/>
    <id>https://stevens1995.github.io/2017/09/07/DOM相关/</id>
    <published>2017-09-07T04:52:50.000Z</published>
    <updated>2017-09-07T04:58:19.917Z</updated>
    
    <content type="html"><![CDATA[<h4>Document Object Model</h4>

<p>DOM(document object model)是针对HTML和XML的一个API。DOM描述了一个层次化的节点树，允许开发人员添加、修改和删除节点。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;Document Object Model&lt;/h4&gt;

&lt;p&gt;DOM(document object model)是针对HTML和XML的一个API。DOM描述了一个层次化的节点树，允许开发人员添加、修改和删除节点。&lt;/p&gt;

    
    </summary>
    
    
      <category term="javascript" scheme="https://stevens1995.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>XSS和CSRF初步了解</title>
    <link href="https://stevens1995.github.io/2017/09/06/XSS%E5%92%8CCSRF%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3/"/>
    <id>https://stevens1995.github.io/2017/09/06/XSS和CSRF初步了解/</id>
    <published>2017-09-06T01:31:53.000Z</published>
    <updated>2017-09-06T02:35:34.728Z</updated>
    
    <content type="html"><![CDATA[<h4>XSS &amp; CSRF</h4>

<p>XSS:cross-site-scripting 跨站点脚本<br>CSRF:cross-site-request-forgery 跨站点请求伪造</p>
<p>XSS：攻击者不直接锁定要攻击的目标，通过向某些存在漏洞的网站（比如将用户输入不经过验证直接输出到网站）注入脚本，等到用户访问网站时，脚本运行从而达到攻击的目的。</p>
<p>存储型XSS:<br><img src="https://raw.githubusercontent.com/Stevens1995/blogImages/master/20170906/sorted-XSS.png" alt="XSS"></p>
<a id="more"></a>
<p>XSS的类型：</p>
<p>存储型（stored XSS）：又叫做持续型，注入的数据（被攻击者接收的数据）会存储在服务端，比如服务器。<br>反射型（reflected XSS）：用户的输入立即返回<br>基于DOM的XSS（DOM based XSS）：数据来源和数据接收的地方都是DOM，数据流不会离开客户端</p>
<p>防止XSS攻击：验证来自于客户端的数据或进行相关的处理</p>
<p>CSRF：攻击者通过已经通过验证，服务端完全信任的客户端（被攻击者）来发送http请求，从而达到攻击的目的</p>
<p><img src="https://raw.githubusercontent.com/Stevens1995/blogImages/master/20170906/csrf.png" alt="CSRF"></p>
<p>e.g. 攻击者向被攻击者发送一个图片 <code>&lt;img src=&quot;/attack?transferfund=4000&quot; alt=&quot;&quot;&gt;</code> 诱导被攻击者点击后，发送给服务器，服务器以为是经过认证的被攻击者发送的正常的请求，所以请求相映成功。</p>
<p>防止CSRF： 1.每次打开一个会话服务端向客户端发送一个唯一的不可预测的随机的数，每个正常的http请求都会隐蔽的带着这个随机数，从而让服务端能够判断是否是CSRF攻击请求<br>2.强制用户重新认证</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;XSS &amp;amp; CSRF&lt;/h4&gt;

&lt;p&gt;XSS:cross-site-scripting 跨站点脚本&lt;br&gt;CSRF:cross-site-request-forgery 跨站点请求伪造&lt;/p&gt;
&lt;p&gt;XSS：攻击者不直接锁定要攻击的目标，通过向某些存在漏洞的网站（比如将用户输入不经过验证直接输出到网站）注入脚本，等到用户访问网站时，脚本运行从而达到攻击的目的。&lt;/p&gt;
&lt;p&gt;存储型XSS:&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Stevens1995/blogImages/master/20170906/sorted-XSS.png&quot; alt=&quot;XSS&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="security" scheme="https://stevens1995.github.io/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>javascript事件模型</title>
    <link href="https://stevens1995.github.io/2017/09/05/javascript%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/"/>
    <id>https://stevens1995.github.io/2017/09/05/javascript事件模型/</id>
    <published>2017-09-05T01:01:11.000Z</published>
    <updated>2017-09-05T01:40:04.126Z</updated>
    
    <content type="html"><![CDATA[<h4>javascript事件模型</h4>


<h4>事件流：</h4>

<p>IE事件流：事件冒泡：事件最开始由具体的的元素接收，然后向上传播至不具体的节点。</p>
<p>Netscape: 事件捕获：不具体的的节点先接收到事件，具体的节点后接收到事件。</p>
<p>DOM事件流：事件捕获阶段、处于目标阶段、事件冒泡阶段。</p>
<a id="more"></a>
<h4>事件处理程序：</h4>

<p>HTML事件处理程序：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">onclick</span>=<span class="string">"alert('clicked.')"</span>&gt;</span></div></pre></td></tr></table></figure>
<p>this的值等于目标元素</p>
<p>DOM0级事件处理程序：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'mybtn'</span>);</div><div class="line"></div><div class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	alert(<span class="keyword">this</span>.id);</div><div class="line">&#125;</div><div class="line"></div><div class="line">btn.onclick = <span class="literal">null</span>;<span class="comment">//删除事件处理程序</span></div></pre></td></tr></table></figure>
<p>this指向目标元素</p>
<p>DOM2级事件处理程序：</p>
<p><code>addEventListener &amp; removeEventListener</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'mybtn'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	alert(<span class="keyword">this</span>.id);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">btn.addEventListener(<span class="string">'click'</span>,handle,<span class="literal">false</span>);<span class="comment">//true表示在事件捕获阶段处理程序，fasle表示在事件冒泡阶段处理程序</span></div><div class="line"></div><div class="line">btn.addEventListener(<span class="string">'click'</span>,handle,<span class="literal">true</span>);<span class="comment">//可以在事件捕获阶段再定义处理程序，与冒泡阶段互不影响，移除的时候也要分别移除</span></div><div class="line"></div><div class="line"></div><div class="line">btn.addEventListener(<span class="string">'click'</span>,handle2,<span class="literal">false</span>);</div><div class="line"></div><div class="line"><span class="comment">//可以添加多个事件处理程序，按照定义的顺序执行</span></div><div class="line"></div><div class="line"></div><div class="line">btn.removeEventListener(<span class="string">'click'</span>,handle,<span class="literal">false</span>);</div></pre></td></tr></table></figure>
<p>IE事件处理程序：</p>
<p><code>attachEvent &amp; detachEvent</code></p>
<p>通过attach添加的时间处理程序只会在冒泡阶段发生。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'mybtn'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</div><div class="line">&#125;</div><div class="line"></div><div class="line">btn.attachEvent(<span class="string">'onclick'</span>,handle);<span class="comment">//与DOM2不同的是这里添加的是时间处理程序的名称不是事件名称</span></div><div class="line"></div><div class="line">btn.detachEvent(<span class="string">'onclick'</span>,handle);</div></pre></td></tr></table></figure>
<h4>跨浏览器处理程序：</h4>

<p>检测对应的对象是否存在然后决定使用哪个，注意检测顺序：DOM2 -&gt; IE -&gt;HTML事件处理程序</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;javascript事件模型&lt;/h4&gt;


&lt;h4&gt;事件流：&lt;/h4&gt;

&lt;p&gt;IE事件流：事件冒泡：事件最开始由具体的的元素接收，然后向上传播至不具体的节点。&lt;/p&gt;
&lt;p&gt;Netscape: 事件捕获：不具体的的节点先接收到事件，具体的节点后接收到事件。&lt;/p&gt;
&lt;p&gt;DOM事件流：事件捕获阶段、处于目标阶段、事件冒泡阶段。&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript事件模型" scheme="https://stevens1995.github.io/tags/javascript%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>TCP三次握手四次挥手</title>
    <link href="https://stevens1995.github.io/2017/09/04/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>https://stevens1995.github.io/2017/09/04/TCP三次握手四次挥手/</id>
    <published>2017-09-04T06:32:25.000Z</published>
    <updated>2017-09-04T07:13:22.187Z</updated>
    
    <content type="html"><![CDATA[<h4>TCP三次握手四次挥手</h4>


<h4>three handshake:</h4>


<p><img src="https://raw.githubusercontent.com/Stevens1995/blogImages/master/20170904/handshake.png" alt="tcp_handshake"></p>
<a id="more"></a>
<p>1.首先客户端的TCP首先向服务端发送一个特殊的TCP报文段，报文段首部的SYN标志位被置为1，另外，客户端会随机地选择一个初始序号(seq)，并将此编号放置于该报文段的序号字段中，随后报文被封装到一个IP数据报中并发送给服务器</p>
<p>2.服务器提取出TCP报文段,为该TCP连接分配TCP缓存和变量，并想该客户端TCP发送允许连接的报文段。报文段的SYN标志位置为1，首部确认号字段被置为seq+1，最后服务端选择自己的初始序列号seq。</p>
<p>3.客户端TCP收到服务端允许连接的报文段后，客户端也要为该连接分配缓存和变量。客户端再向服务器发送确认报文段，序号seq为之前的序号加一，确认字段ACK为seq_server加一，最后一部SYN置为0，连接建立。</p>
<h4>four waved:</h4>



<p><img src="https://raw.githubusercontent.com/Stevens1995/blogImages/master/20170904/waved.png" alt=""></p>
<p>一个TCP连接中的双方都能终止连接，比如客户端要终止连接，客户端即发送TCP报文段，FIN标志位置为1，服务端收到后发送一个确认报文段，客户端联机即终止。服务端要终止的话也要进行相同的操作。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;TCP三次握手四次挥手&lt;/h4&gt;


&lt;h4&gt;three handshake:&lt;/h4&gt;


&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Stevens1995/blogImages/master/20170904/handshake.png&quot; alt=&quot;tcp_handshake&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>事件委托</title>
    <link href="https://stevens1995.github.io/2017/09/04/%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/"/>
    <id>https://stevens1995.github.io/2017/09/04/事件委托/</id>
    <published>2017-09-04T03:22:56.000Z</published>
    <updated>2017-09-06T11:34:33.278Z</updated>
    
    <content type="html"><![CDATA[<h4>javascript delegation(事件委托)</h4>

<p>事件委托能够避免在js中为很多具体的节点添加事件监听，只需为父元素添加即可。通过父元素的事件监听来分析事件冒泡从而获得匹配的子元素。</p>
<a id="more"></a>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"parent-list"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"post-1"</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"post-2"</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"post-3"</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"post-4"</span>&gt;</span>Item 4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"post-5"</span>&gt;</span>Item 5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"post-6"</span>&gt;</span>Item 6<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// Get the element, add a click listener...</span></div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">"parent-list"</span>).addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">	<span class="comment">// e.target is the clicked element!</span></div><div class="line">	<span class="comment">// If it was a list item</span></div><div class="line">	<span class="keyword">if</span>(e.target &amp;&amp; e.target.nodeName == <span class="string">"LI"</span>) &#123;</div><div class="line">		<span class="comment">// List item found!  Output the ID!</span></div><div class="line">		<span class="built_in">console</span>.log(<span class="string">"List item "</span>, e.target.id.replace(<span class="string">"post-"</span>, <span class="string">""</span>), <span class="string">" was clicked!"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;javascript delegation(事件委托)&lt;/h4&gt;

&lt;p&gt;事件委托能够避免在js中为很多具体的节点添加事件监听，只需为父元素添加即可。通过父元素的事件监听来分析事件冒泡从而获得匹配的子元素。&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="https://stevens1995.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Grid详解</title>
    <link href="https://stevens1995.github.io/2017/08/31/Grid%E8%AF%A6%E8%A7%A3/"/>
    <id>https://stevens1995.github.io/2017/08/31/Grid详解/</id>
    <published>2017-08-31T10:02:20.000Z</published>
    <updated>2017-09-04T07:13:24.328Z</updated>
    
    <content type="html"><![CDATA[<h4>Grid详解</h4>

<h4>Grid container属性:</h4>

<p><code>display</code>:定义一个grid容器</p>
<p><code>grid | inline-grid | subgrid</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">grid:定义块级grid容器  </div><div class="line"></div><div class="line">inline-grid:定义行级grid容器  </div><div class="line"></div><div class="line">subgrid:容器本身是grid项目</div></pre></td></tr></table></figure>
<a id="more"></a>
<p><code>grid-template-columns</code> &amp; <code>grid-template-rows</code>：定义容器的行和列</p>
<p><code>track-size | line-name</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">track-size:行的尺寸</div><div class="line"></div><div class="line">line-name:行之间的线的名字</div><div class="line"></div><div class="line">fr: fr单位允许将轨道的尺寸设计为容器可用空间的一部分。</div></pre></td></tr></table></figure>
<p><code>grid-template-area</code>:定义网格模板，通过项目的grid-area属性</p>
<p><code>&lt;grid-area-name&gt; | . | name</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">grid-arem-name:项目中指明的名字</div><div class="line"></div><div class="line">. :一个点代表一个空的grid网格单元</div><div class="line"></div><div class="line">none:无</div></pre></td></tr></table></figure>
<p><code>grid-template</code>：grid-template-rows、grid-template-columns、grid-template-area的简写</p>
<p><code>none | subgrid | &lt;grid-template-rows&gt;/&lt;grid-template-columns&gt;</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">none:设置三个值为他们的默认值</div><div class="line"></div><div class="line">subgrid:</div><div class="line"></div><div class="line">grid-template-rows &amp; grid-template-columns:</div></pre></td></tr></table></figure>
<p><code>grid-column-gap</code> &amp; <code>grid-row-gap</code>:设置行和列之间间隙的大小</p>
<p><code>grid-gap</code>:grid-column-gap 和 grid-row-gap的简写</p>
<p><code>justify-items</code>:排列行上的项目</p>
<p><code>align-items</code>:排列列上的项目</p>
<p><code>justify-content</code>:分配行上的空间</p>
<p><code>align-content</code>:分配列上的空间</p>
<p><code>grid-auto-columns</code> &amp; <code>grid-auto-rows</code>:设定自动生成的行和列的大小</p>
<p><code>grid-auto-flow</code>:定义项目如何在容器内自动排列</p>
<p><code>grid</code>:以上所有属性的简写</p>
<h4>Grid items属性:</h4>

<p><code>grid-column-start</code></p>
<p><code>grid-column-end</code></p>
<p><code>grid-row-start</code></p>
<p><code>grid-row-end</code></p>
<p><code>grid-column</code></p>
<p><code>grid-row</code></p>
<p><code>grid-area</code>:为一个项目指定一个名字，还可以作为 gird-column(row)-start(end)的简写</p>
<p><code>justify-self</code>:分配项目中行上剩余的空间</p>
<p><code>align-self</code>:分配项目中列上剩余的空间 </p>
]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;Grid详解&lt;/h4&gt;

&lt;h4&gt;Grid container属性:&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;display&lt;/code&gt;:定义一个grid容器&lt;/p&gt;
&lt;p&gt;&lt;code&gt;grid | inline-grid | subgrid&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;grid:定义块级grid容器  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;inline-grid:定义行级grid容器  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;subgrid:容器本身是grid项目&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="css" scheme="https://stevens1995.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Flex详解</title>
    <link href="https://stevens1995.github.io/2017/08/30/Flex%E8%AF%A6%E8%A7%A3/"/>
    <id>https://stevens1995.github.io/2017/08/30/Flex详解/</id>
    <published>2017-08-30T06:26:22.000Z</published>
    <updated>2017-09-04T07:13:28.884Z</updated>
    
    <content type="html"><![CDATA[<h4>Flex详解</h4>

<h4>总览:</h4>

<p><img src="https://raw.githubusercontent.com/Stevens1995/blogImages/master/20170830/flexbox.png" alt="flex总览"></p>
<a id="more"></a>
<h4>Flex container属性:</h4>

<p><code>display:flex:</code>定义一个Flex容器</p>
<p><code>flex-direction:</code> 建立主轴，定义项目在主轴上的排列方向 </p>
<p>row | row-reverse | column | column-reverse<br>row(默认):主轴水平方向，项目从左到右排列<br>row-reverse:主轴水平，项目从右到左<br>column:主轴垂直，项目从上到下<br>column:主轴垂直，项目从下到上</p>
<p><code>flex-wrap:</code>默认的所有项目在主轴上排列，不换行，可通过flex-wrap来改变  </p>
<p><code>nowrap | wrap | wrap-reverse</code></p>
<p>nowrap(默认):所有项目排列在主轴上不换行<br>wrap:换行，项目从顶部到底部<br>wrap-reverse:不换行，项目从底部到顶部</p>
<p><code>flex-flow:</code> flex-direction 和 flex-wrap的简写</p>
<p>flex-flow: &lt;’flex-direction’&gt; || &lt;’felx-wrap’&gt;</p>
<p><code>justify-content:</code>定义项目在主轴上的排列</p>
<p><code>flex-start | flex-end | center | space-between | space-around | space-evenly</code></p>
<p>flex-start(默认):项目从主轴开始的地方开始排列<br>flex-end:从主轴结束的地方开始排列<br>center:项目排列在主轴中间<br>space-between:项目均匀分布在主轴上，第一个在开始线，最后一个在结束线，中间的项目均匀分布<br>space-around:每个项目左边和右边的空隙一样(注意，中间的间隔是左右间隔的两倍)<br>space-evenly:项目间的间隔一样(所有间隔都一样)</p>
<p><code>align-items:</code>项目在交叉轴上的布局</p>
<p><code>flex-start | flex-end | center | stretch | baseline</code></p>
<p>flex-start:项目在交叉轴的边缘从交叉轴的开始处开始<br>flex-end:项目在交叉轴的边缘从交叉轴的结束处开始<br>center:f项目处在交叉轴中间<br>baseline:项目根据基线对齐<br>stretch:伸展填充container  </p>
<p><code>align-content:</code>排列 主轴上的行 在交叉轴上的空间 (当主轴只有一行时这个属性不起作用)</p>
<p><code>flex-start | flex-end | center | space-between | space-around | stretch</code></p>
<p>flex-start:行从交叉轴开始的地方排列<br>flex-end:行从交叉轴结束的地方开始排列<br>center:行在交叉轴的中间<br>space-between:行之间的间隔相等，第一行在交叉轴开始线处，最后一行在交叉轴结束线处<br>space-around:每行左右间距相同<br>stretch:行伸展以填充container</p>
<h4>Flex items属性:</h4>

<p><code>order:</code>定义项目排列的顺序</p>
<p>order:<integer></integer></p>
<p><code>flex-grow:</code>:定义项目扩大的能力，接收一个没有单位的值代表比例，决定占据多少主轴上剩余的可用空间  </p>
<p><code>flex-shrink:</code>定义项目缩小的能力(负值无效)  </p>
<p><code>flex-basis:</code>定义在分配剩余空间之前项目的默认大小</p>
<p><code>flex:</code>前面三个属性的简写</p>
<p>flex: flex-grow || flex-shrink || flex-basis</p>
<p><code>align-self:</code>定义个别项目在交叉轴上排列方式，这可以覆盖在container上定义的align-item属性</p>
<p><code>flex-start | flex-end</code></p>
<p>flex-start:从交叉轴的开始线处开始排列<br>flex-end:从交叉轴的结束线处开始排列</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;Flex详解&lt;/h4&gt;

&lt;h4&gt;总览:&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Stevens1995/blogImages/master/20170830/flexbox.png&quot; alt=&quot;flex总览&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="CSS" scheme="https://stevens1995.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>slice &amp; splice</title>
    <link href="https://stevens1995.github.io/2017/08/22/sliceandsplice/"/>
    <id>https://stevens1995.github.io/2017/08/22/sliceandsplice/</id>
    <published>2017-08-22T11:30:36.000Z</published>
    <updated>2017-08-28T14:16:26.989Z</updated>
    
    <content type="html"><![CDATA[<h4>Array.prototype.slice &amp; Array.prototype.splice</h4>

<p>Array.prototype.slice 返回从开始索引到结束索引的数组(不包括结束)，不改变原数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line">a.slice(<span class="number">0</span>,<span class="number">2</span>);<span class="comment">//[1,2]</span></div></pre></td></tr></table></figure>
<p>Array.prototype.splce 从开始索引删除指定个数的元素(包括开始)，改变原数组，返回删除的元素组成的数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line">a.splice(<span class="number">0</span>,<span class="number">2</span>);<span class="comment">// [1,2]</span></div><div class="line">a <span class="comment">//[3,4,5]</span></div></pre></td></tr></table></figure>
<a id="more"></a>
]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;Array.prototype.slice &amp;amp; Array.prototype.splice&lt;/h4&gt;

&lt;p&gt;Array.prototype.slice 返回从开始索引到结束索引的数组(不包括结束)，不改变原数组&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;a.slice(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//[1,2]&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Array.prototype.splce 从开始索引删除指定个数的元素(包括开始)，改变原数组，返回删除的元素组成的数组&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;a.splice(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;// [1,2]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;a &lt;span class=&quot;comment&quot;&gt;//[3,4,5]&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://stevens1995.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://stevens1995.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>sass</title>
    <link href="https://stevens1995.github.io/2017/08/21/sass/"/>
    <id>https://stevens1995.github.io/2017/08/21/sass/</id>
    <published>2017-08-21T15:16:47.000Z</published>
    <updated>2017-08-22T12:16:20.214Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="css" scheme="https://stevens1995.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://stevens1995.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>FunctionalPrograming</title>
    <link href="https://stevens1995.github.io/2017/08/19/FunctionalPrograming/"/>
    <id>https://stevens1995.github.io/2017/08/19/FunctionalPrograming/</id>
    <published>2017-08-19T09:08:07.000Z</published>
    <updated>2017-09-04T07:13:25.925Z</updated>
    
    <content type="html"><![CDATA[<h4>Functional Programing(函数式编程)</h4>


<p>函数式编程(Functional Programing、FP)通过构建纯函数来编程，避免了状态共享(shared state)、可变的数据(mutable data)、副作用(side-effects)。函数式编程是声明式(declarative)而不是命令式(imperative)的编程。</p>
<p>函数式编程是一种编程方法、模式，类同于面向对象编程、过程式编程。</p>
<a id="more"></a>
<h5>掌握函数式编程需要理解的几个概念：</h5>

<p>纯函数(pure function)、函数组合(function composition)、避免共享状态(avoid shared state)、避免突变状态(avoid mutation state)、避免副作用(avoid side-effects)</p>
<h6>纯函数是拥有以下特性的函数：</h6>  

<p>1.相同的输入对应相同的输出<br>2.没有副作用</p>
<p>并且，纯函数有许多对函数式编程来说很重要的特性，比如引用透明性(referential transparency，指可以用函数的返回值替代函数而不对代码的含义产生影响)</p>
<h6>函数组合：</h6><br>将多个函数组合起来以产生一个新的函数或者执行某些计算，e.g.f(g(x))<br><br><h6>共享状态(shared state)：</h6><br>共享状态可以包含以下情形：共享作用域中的变量、对象或者内存空间，在多个作用域中传递的对象的属性<br><br>共享状态的弊端：<br>1.改变函数的执行顺序和时间会产生一些不同的结果<br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> x = &#123;</div><div class="line">	val:<span class="number">2</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> x1 = <span class="function"><span class="params">()</span>=&gt;</span>x.val+=<span class="number">1</span>;</div><div class="line"><span class="keyword">const</span> x2 = <span class="function"><span class="params">()</span>=&gt;</span>x.val*=<span class="number">2</span>;</div><div class="line"></div><div class="line">x1();</div><div class="line">x2(); </div><div class="line"><span class="built_in">console</span>.log(x.val); <span class="comment">//6</span></div><div class="line"></div><div class="line"><span class="comment">//another order</span></div><div class="line">x2();</div><div class="line">x1();</div><div class="line"><span class="built_in">console</span>.log(x.val)<span class="comment">//5</span></div></pre></td></tr></table></figure><br><br>避免了共享状态后，函数的顺序不会影响执行结果：<br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> y = &#123;</div><div class="line">	val:<span class="number">2</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> y1 = <span class="function"><span class="params">y</span>=&gt;</span><span class="built_in">Object</span>.assign(&#123;&#125;,y,&#123; <span class="attr">val</span>:x.val+<span class="number">1</span>&#125;);</div><div class="line"><span class="keyword">const</span> y2 = <span class="function"><span class="params">y</span>=&gt;</span><span class="built_in">Object</span>.assign(&#123;&#125;,y,&#123; <span class="attr">val</span>:x.val*<span class="number">2</span>&#125;);</div><div class="line"></div><div class="line"><span class="comment">//在此你可以执行任意的代码，而不会影响到后面的输出，因为函数不依赖于后面执行函数的依赖的状态</span></div><div class="line">y1();</div><div class="line">y2();</div><div class="line"></div><div class="line"><span class="comment">//或者</span></div><div class="line">y2();</div><div class="line">y1();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(y1(y2(y).val));</div></pre></td></tr></table></figure><br><br><h6>永恒性(immutability):</h6>

<p>不能通过const来定义不可变的对象，const只是指定变量的引用的对象不能改变，可以改变对象的属性。</p>
<p>Object.freeze()方法也不能完全是对象不可变，比如对象中又有对象，除非使用Object.freeze()方法来封住每一层的对象。</p>
<h6>副作用：</h6>

<p>在函数式编程中，副作用指的是任何在调用的函数之外可以检测到的应用程序状态的改变。</p>
<h5>通过高阶函数的可重用性(reusability though high order function)：</h5>

<h5></h5>
]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;Functional Programing(函数式编程)&lt;/h4&gt;


&lt;p&gt;函数式编程(Functional Programing、FP)通过构建纯函数来编程，避免了状态共享(shared state)、可变的数据(mutable data)、副作用(side-effects)。函数式编程是声明式(declarative)而不是命令式(imperative)的编程。&lt;/p&gt;
&lt;p&gt;函数式编程是一种编程方法、模式，类同于面向对象编程、过程式编程。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://stevens1995.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://stevens1995.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Flex</title>
    <link href="https://stevens1995.github.io/2017/08/16/Flex/"/>
    <id>https://stevens1995.github.io/2017/08/16/Flex/</id>
    <published>2017-08-16T11:39:48.000Z</published>
    <updated>2017-09-04T07:13:27.500Z</updated>
    
    <content type="html"><![CDATA[<h4>Flex中关于flex-grow与flex-shrink的计算</h4>

<p>Flex容器中的项目<code>Flex</code>属性简写</p>
<p><code>flex:1 0 150px;</code><br>这个简写能被拆分成三个属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">flex-grow:<span class="number">1</span>;</div><div class="line"></div><div class="line">flex-shrink:<span class="number">0</span>;</div><div class="line"></div><div class="line">felx-basis:<span class="number">150</span>px;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h5>flex-grow</h5>

<p>定义容器中项目的增长，当容器空间有剩余时，计算方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">增长的长度 = 剩余空间 × (某个项目的flex-grow属性值/所有项目flex-grow属性值的和)</div></pre></td></tr></table></figure>
<h5>flex-shrink</h5>

<p>定义容器中项目的收缩，当容器空间不够时，计算方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">总和 = 每个项目的flex-shrink的值 × 项目的flex-basis值</div><div class="line"></div><div class="line">项目缩小的长度 = 超过的空间 × (每个项目的flex-shrink的值×项目的flex-basis)</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;Flex中关于flex-grow与flex-shrink的计算&lt;/h4&gt;

&lt;p&gt;Flex容器中的项目&lt;code&gt;Flex&lt;/code&gt;属性简写&lt;/p&gt;
&lt;p&gt;&lt;code&gt;flex:1 0 150px;&lt;/code&gt;&lt;br&gt;这个简写能被拆分成三个属性：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;flex-grow:&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;flex-shrink:&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;felx-basis:&lt;span class=&quot;number&quot;&gt;150&lt;/span&gt;px;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="css" scheme="https://stevens1995.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://stevens1995.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>CommonJS vs AMD vs ES2015module</title>
    <link href="https://stevens1995.github.io/2017/06/03/CommonJSvsAMDvsES2015module/"/>
    <id>https://stevens1995.github.io/2017/06/03/CommonJSvsAMDvsES2015module/</id>
    <published>2017-06-03T09:56:41.000Z</published>
    <updated>2017-08-28T14:07:17.663Z</updated>
    
    <content type="html"><![CDATA[<h4>常见的JavaScript模块系统总结，不同标准的特点以及区别。</h4>

<p>参考并翻译此文章: <a href="https://auth0.com/blog/javascript-module-systems-showdown/" target="_blank" rel="external">https://auth0.com/blog/javascript-module-systems-showdown/</a></p>
<p><strong><em>COMMONJS:</em></strong></p>
<p>CommonJS致力于定义一系列的规范来帮助进行服务端的JavaScript开发。其中一个CommonJS尝试解决的领</p>
<p>域就是模块化。Node.js开发者最初打算遵循CommonJS规范，但是后来决定放弃。但是node.js的实现很大</p>
<p>程度上受到了CommonJS的影响。（也就是说node.js并没有完全遵循CommonJS规范）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In circle.js</span></div><div class="line"><span class="keyword">const</span> PI = <span class="built_in">Math</span>.PI;</div><div class="line"></div><div class="line">exports.area = <span class="function">(<span class="params">r</span>) =&gt;</span> PI * r * r;</div><div class="line"></div><div class="line">exports.circumference = <span class="function">(<span class="params">r</span>) =&gt;</span> <span class="number">2</span> * PI * r;</div><div class="line"></div><div class="line"><span class="comment">// In some file</span></div><div class="line"><span class="keyword">const</span> circle = <span class="built_in">require</span>(<span class="string">'./circle.js'</span>);</div><div class="line"><span class="built_in">console</span>.log( <span class="string">`The area of a circle of radius 4 is <span class="subst">$&#123;circle.area(<span class="number">4</span>)&#125;</span>`</span>);</div></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>“Forget CommonJS. It’s dead. We are server side JavaScript.” - NPM creator Isaac Z. Schlueter quoting Node.js creator Ryan Dahl</strong> </p>
<p>在Node.js中，模块系统抽象为库的形式，这减小了Node.js和CommonJS的差异。在这片文章中我们只谈论一些</p>
<p>在二者中大致相同的功能。</p>
<p>在Node.js和CommonJS中，本质上都是用两个对象来和模块系统进行交换：<code>require</code>和<code>exports</code>。</p>
<p><code>require</code>是一个函数，用来将其他模块导入到当前作用域。传递给<code>require</code>的参数时模块的id。</p>
<p>在node.js中，是在<code>node_modules</code>文件夹下的模块名。（如果不是，也可以传递文件的路径）<code>exports</code></p>
<p>是一个特殊的对象，任何传递到其中的对象或者变量将会作为公共元素导出。Node和CommonJS一个奇特的区别在于</p>
<p><code>module.exports</code>对象。在Node中，<code>module.exports</code>是一个特殊的会被导出的对象，<code>exports</code>是一个默认绑定到</p>
<p><code>module.exports</code>的变量。CommonJS中则没有<code>module.exports</code>对象。这在实际应用中体现在，</p>
<p>Node必须通过<code>module.exports</code>导出一个对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// This won't work, replacing exports entirely breaks the binding to</span></div><div class="line"><span class="comment">// modules.exports.</span></div><div class="line">exports =  <span class="function">(<span class="params">width</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    area: <span class="function"><span class="params">()</span> =&gt;</span> width * width</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// This works as expected.</span></div><div class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">width</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    area: <span class="function"><span class="params">()</span> =&gt;</span> width * width</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>CommonJS模块是为服务端开发进行设计。API是同步的，换句话说，模块按照他们在文件中<code>require</code>的时间和顺序进行加载。</p>
<p><strong>CommonJS modules were designed with serve development in mind.</strong></p>
<p>优点：</p>
<p>1.简单：开发者能够轻易理解。</p>
<p>2.依赖管理集成：模块可以<code>require</code>其他模块并且按需要加载。</p>
<p>3.<code>require</code>可以在任何地方被调用：模块可以以编程的方式加载。</p>
<p>4.支持循环依赖</p>
<p>缺点：</p>
<p>1.同步的API使他不适合某些用途。（客户端）。</p>
<p>2.一个模块一个文件</p>
<p>3.Browsers require a loader library or transpiling.</p>
<p>4.没有模块的构造函数 (Node支持).</p>
<p>5.Hard to analyze for static code analyzers.</p>
<p>CommonJS的实现: <code>Node.js</code></p>
<p><br><br><br><br><strong>AMD(Asynchronous Module Definition):</strong></p>
<p>AMD出自一群对CommonJS采用的方向感到不满的开发者。事实上，AMD was split from CommonJS early in its development。</p>
<p>AMD与CommonJS的不同之处在于AMD对于模块异步加载的支持。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Calling define with a dependency array and a factory function</span></div><div class="line">define([<span class="string">'dep1'</span>, <span class="string">'dep2'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">dep1, dep2</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//Define the module value by returning a value.</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// Or:</span></div><div class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> dep1 = <span class="built_in">require</span>(<span class="string">'dep1'</span>),</div><div class="line">        dep2 = <span class="built_in">require</span>(<span class="string">'dep2'</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>使用javascript传统闭包的用法让异步加载成为可能:在请求的模块加载完成时调用回调函数。</p>
<p>模块的定义和模块的导入由同一个函数承载。当一个模块被定义，他的依赖就明确下来。因此，</p>
<p>AMD加载器在运行时拥有给定项目的完整的依赖图。 没有依赖关系的模块就能够同时加载。这</p>
<p>对于浏览器来说尤其重要，启动时间对于用户体验至关重要。</p>
<p>优点：<br>1.异步加载(更快的启动时间)</p>
<p>2.支持循环依赖</p>
<p>3.Dependency management fully integrated.</p>
<p>4.兼容<code>require</code>和<code>exports</code></p>
<p>5.如果需要的话一个模块可以分到多个文件中。</p>
<p>6.支持构造函数。</p>
<p>7.插件支持。（自定义加载步骤）</p>
<p>缺点：<br>1.略微复杂的语法</p>
<p>2.Loader libraries are required unless transpiled.</p>
<p>3.Hard to analyze for static code analyzers.</p>
<p>AMD实现：目前比较受欢迎的实现由<code>Require.js</code>和<code>Dojo</code></p>
<p><br><br><br><br><strong>ES2015：</strong></p>
<p>幸运的是，JavaScript背后负责标准化的ECMA团队决定处理模块问题。</p>
<p>解决的结果能在最近发布的JavaScript标准中看到：ECMAScript2015（ECMAScript6）</p>
<p>结果在语法上更令人愉悦，并且兼容同步和异步模式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//------ lib.js ------</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> sqrt = <span class="built_in">Math</span>.sqrt;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x * x;</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">diag</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> sqrt(square(x) + square(y));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//------ main.js ------</span></div><div class="line"><span class="keyword">import</span> &#123; square, diag &#125; <span class="keyword">from</span> <span class="string">'lib'</span>;</div><div class="line"><span class="built_in">console</span>.log(square(<span class="number">11</span>)); <span class="comment">// 121</span></div><div class="line"><span class="built_in">console</span>.log(diag(<span class="number">4</span>, <span class="number">3</span>)); <span class="comment">// 5</span></div></pre></td></tr></table></figure>
<p><code>import</code>能用于将模块引入命名空间，<code>import</code>指令与<code>require</code>和<code>define</code>指令对比</p>
<p>来说不是动态的。（也就是说不能在所有地方调用）。<code>export</code>指令能够明确地将公开</p>
<p>元素</p>
<p><code>import</code>和<code>export</code>指令的静态特性允许静态分析器构建完整的依赖关系树，而不运行代码。</p>
<p><strong>最新ECMAScript标准支持动态加载模块，这是ECMAScript标准未来发布版本的提案。</strong></p>
<p>ES2015实现：目前木有。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;常见的JavaScript模块系统总结，不同标准的特点以及区别。&lt;/h4&gt;

&lt;p&gt;参考并翻译此文章: &lt;a href=&quot;https://auth0.com/blog/javascript-module-systems-showdown/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://auth0.com/blog/javascript-module-systems-showdown/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;COMMONJS:&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CommonJS致力于定义一系列的规范来帮助进行服务端的JavaScript开发。其中一个CommonJS尝试解决的领&lt;/p&gt;
&lt;p&gt;域就是模块化。Node.js开发者最初打算遵循CommonJS规范，但是后来决定放弃。但是node.js的实现很大&lt;/p&gt;
&lt;p&gt;程度上受到了CommonJS的影响。（也就是说node.js并没有完全遵循CommonJS规范）。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// In circle.js&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; PI = &lt;span class=&quot;built_in&quot;&gt;Math&lt;/span&gt;.PI;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;exports.area = &lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;r&lt;/span&gt;) =&amp;gt;&lt;/span&gt; PI * r * r;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;exports.circumference = &lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;r&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; * PI * r;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// In some file&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; circle = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;./circle.js&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log( &lt;span class=&quot;string&quot;&gt;`The area of a circle of radius 4 is &lt;span class=&quot;subst&quot;&gt;$&amp;#123;circle.area(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)&amp;#125;&lt;/span&gt;`&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="programing" scheme="https://stevens1995.github.io/categories/programing/"/>
    
    
      <category term="programing" scheme="https://stevens1995.github.io/tags/programing/"/>
    
  </entry>
  
  <entry>
    <title>javascript中几个概念</title>
    <link href="https://stevens1995.github.io/2017/05/30/javascript%E4%B8%AD%E5%87%A0%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    <id>https://stevens1995.github.io/2017/05/30/javascript中几个概念/</id>
    <published>2017-05-30T08:28:50.000Z</published>
    <updated>2017-08-28T14:15:43.531Z</updated>
    
    <content type="html"><![CDATA[<p>关于javascript中几个概念的解释:</p>
<p><strong><em>1.执行上下文（Execution Context）</em></strong></p>
<p>通俗来说就是函数执行时的环境，包括下面几个部分： </p>
<p>变量对象、作用域链、this</p>
<p><strong><em>2.活动对象（Activation Object）</em></strong></p>
<p>形参、arguments对象、函数中定义的变量和函数</p>
<p><strong><em>3.变量对象（Variable Object）</em></strong></p>
<p>在全局上下文中，global object</p>
<p>在函数中，activation object</p>
<p><strong><em>4.作用域链 （Scope Chain）</em></strong></p>
<p>作用域（scope）:在JavaScript中，作用域是你可以访问的变量、对象、函数的集合。<br><a id="more"></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于javascript中几个概念的解释:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;1.执行上下文（Execution Context）&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通俗来说就是函数执行时的环境，包括下面几个部分： &lt;/p&gt;
&lt;p&gt;变量对象、作用域链、this&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.活动对象（Activation Object）&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;形参、arguments对象、函数中定义的变量和函数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;3.变量对象（Variable Object）&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在全局上下文中，global object&lt;/p&gt;
&lt;p&gt;在函数中，activation object&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;4.作用域链 （Scope Chain）&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作用域（scope）:在JavaScript中，作用域是你可以访问的变量、对象、函数的集合。&lt;br&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://stevens1995.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://stevens1995.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>undefined和null</title>
    <link href="https://stevens1995.github.io/2017/05/30/undefined%E5%92%8Cnull/"/>
    <id>https://stevens1995.github.io/2017/05/30/undefined和null/</id>
    <published>2017-05-30T06:53:14.000Z</published>
    <updated>2017-09-04T07:13:17.265Z</updated>
    
    <content type="html"><![CDATA[<p>##undefined VS null</p>
<p>undeined表示一个变量已经被声明,但是还没有赋值。</p>
<p>null本身是一个值,可以被赋值给变量,代表‘空值’</p>
<p>undefined本身是一种类型(undefined),null是Object类型(typeof的结果,应该是bug,null也是js的基本类型之一)</p>
<p>js在创建变量时会给变量初始化为undefined,但是js从来不会将某个值初始化为null,必须手动设置为null</p>
<a id="more"></a>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##undefined VS null&lt;/p&gt;
&lt;p&gt;undeined表示一个变量已经被声明,但是还没有赋值。&lt;/p&gt;
&lt;p&gt;null本身是一个值,可以被赋值给变量,代表‘空值’&lt;/p&gt;
&lt;p&gt;undefined本身是一种类型(undefined),null是Object类型(typeof的结果,应该是bug,null也是js的基本类型之一)&lt;/p&gt;
&lt;p&gt;js在创建变量时会给变量初始化为undefined,但是js从来不会将某个值初始化为null,必须手动设置为null&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://stevens1995.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://stevens1995.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>top和left属性值问题</title>
    <link href="https://stevens1995.github.io/2017/05/22/top%E5%92%8Cleft%E5%B1%9E%E6%80%A7%E5%80%BC%E9%97%AE%E9%A2%98/"/>
    <id>https://stevens1995.github.io/2017/05/22/top和left属性值问题/</id>
    <published>2017-05-22T07:33:10.000Z</published>
    <updated>2017-08-28T14:16:33.619Z</updated>
    
    <content type="html"><![CDATA[<p>position为absoulate的元素，元素相对于盒子模型中的padding盒来进行定位。<br>为top、bottom、left、right等设置的值为百分比，进行计算时，top和bottom的值由padding盒的高度乘以百分比得到，left和right的值由padding盒的宽度乘以百分比得到。</p>
<a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;position为absoulate的元素，元素相对于盒子模型中的padding盒来进行定位。&lt;br&gt;为top、bottom、left、right等设置的值为百分比，进行计算时，top和bottom的值由padding盒的高度乘以百分比得到，left和right的值由padding盒的宽度乘以百分比得到。&lt;/p&gt;
    
    </summary>
    
      <category term="css" scheme="https://stevens1995.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://stevens1995.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>javascript中的this</title>
    <link href="https://stevens1995.github.io/2017/05/16/javascript%E4%B8%AD%E7%9A%84this/"/>
    <id>https://stevens1995.github.io/2017/05/16/javascript中的this/</id>
    <published>2017-05-16T11:40:54.000Z</published>
    <updated>2017-08-28T14:16:01.401Z</updated>
    
    <content type="html"><![CDATA[<p>javascript中的<code>this</code>问题</p>
<p>javascript中的<code>this</code>对象取决于你如何调用函数：</p>
<p>通常来说有四种调用函数的方法：</p>
<p>1.<code>someThing.someFunction(arg1, arg2, argN)</code></p>
<p>2.<code>someFunction.call(someThing, arg1, arg2, argN)</code></p>
<p>3.<code>someFunction.apply(someThing, [arg1, arg2, argN])</code></p>
<p>上面三种调用方式，this对象都是<code>someThing</code></p>
<p>4.<code>new someFunction(arg1,arg2,argN)</code><br>使用<code>new</code>关键字，会创建一个Object对象，<code>this</code>是这个新建的对象</p>
<a id="more"></a>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;javascript中的&lt;code&gt;this&lt;/code&gt;问题&lt;/p&gt;
&lt;p&gt;javascript中的&lt;code&gt;this&lt;/code&gt;对象取决于你如何调用函数：&lt;/p&gt;
&lt;p&gt;通常来说有四种调用函数的方法：&lt;/p&gt;
&lt;p&gt;1.&lt;code&gt;someThing.someFunction(arg1, arg2, argN)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;code&gt;someFunction.call(someThing, arg1, arg2, argN)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;3.&lt;code&gt;someFunction.apply(someThing, [arg1, arg2, argN])&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;上面三种调用方式，this对象都是&lt;code&gt;someThing&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;4.&lt;code&gt;new someFunction(arg1,arg2,argN)&lt;/code&gt;&lt;br&gt;使用&lt;code&gt;new&lt;/code&gt;关键字，会创建一个Object对象，&lt;code&gt;this&lt;/code&gt;是这个新建的对象&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://stevens1995.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://stevens1995.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JS传递参数问题</title>
    <link href="https://stevens1995.github.io/2017/05/12/JS%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%E9%97%AE%E9%A2%98/"/>
    <id>https://stevens1995.github.io/2017/05/12/JS传递参数问题/</id>
    <published>2017-05-12T02:49:20.000Z</published>
    <updated>2017-08-28T14:16:18.479Z</updated>
    
    <content type="html"><![CDATA[<p>关于js中函数传递参数时到底是传递值还是传递引用</p>
<p>参考下面代码:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeStuff</span>(<span class="params">a, b, c</span>)</span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  a = a * <span class="number">10</span>;</div><div class="line">  b.item = <span class="string">"changed"</span>;</div><div class="line">  c = &#123;<span class="attr">item</span>: <span class="string">"changed"</span>&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</div><div class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">item</span>: <span class="string">"unchanged"</span>&#125;;</div><div class="line"><span class="keyword">var</span> obj2 = &#123;<span class="attr">item</span>: <span class="string">"unchanged"</span>&#125;;</div><div class="line"></div><div class="line">changeStuff(num, obj1, obj2);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(num);</div><div class="line"><span class="built_in">console</span>.log(obj1.item);    </div><div class="line"><span class="built_in">console</span>.log(obj2.item);</div></pre></td></tr></table></figure></p>
<p>输出结果是:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">10</span></div><div class="line">changed</div><div class="line">unchanged</div></pre></td></tr></table></figure></p>
<p>如果js中全部都是按值传递，那么obj1.item应该不被改变。如果js中全部是按引用传递，那么obj2.item和num应该被改变。<br>实际上，<strong>js中所有的参数都是按值传递</strong>，只不过<strong>有些参数的值本身就是一个引用</strong>，如果改变参数本身的话（比如num和obj1)，不会对外部产生影响，如果改变参数内部属性的话，改变就会应用到函数外部，应用到引用所指向的内存中。</p>
<a id="more"></a>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于js中函数传递参数时到底是传递值还是传递引用&lt;/p&gt;
&lt;p&gt;参考下面代码:&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;changeStuff&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;a, b, c&lt;/span&gt;)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  a = a * &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  b.item = &lt;span class=&quot;string&quot;&gt;&quot;changed&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  c = &amp;#123;&lt;span class=&quot;attr&quot;&gt;item&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;changed&quot;&lt;/span&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; num = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; obj1 = &amp;#123;&lt;span class=&quot;attr&quot;&gt;item&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;unchanged&quot;&lt;/span&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; obj2 = &amp;#123;&lt;span class=&quot;attr&quot;&gt;item&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;unchanged&quot;&lt;/span&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;changeStuff(num, obj1, obj2);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(num);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(obj1.item);    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(obj2.item);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;输出结果是:&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;changed&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;unchanged&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果js中全部都是按值传递，那么obj1.item应该不被改变。如果js中全部是按引用传递，那么obj2.item和num应该被改变。&lt;br&gt;实际上，&lt;strong&gt;js中所有的参数都是按值传递&lt;/strong&gt;，只不过&lt;strong&gt;有些参数的值本身就是一个引用&lt;/strong&gt;，如果改变参数本身的话（比如num和obj1)，不会对外部产生影响，如果改变参数内部属性的话，改变就会应用到函数外部，应用到引用所指向的内存中。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://stevens1995.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://stevens1995.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>clear工作原理</title>
    <link href="https://stevens1995.github.io/2017/05/07/clear%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>https://stevens1995.github.io/2017/05/07/clear工作原理/</id>
    <published>2017-05-07T08:27:19.000Z</published>
    <updated>2017-09-04T07:13:30.380Z</updated>
    
    <content type="html"><![CDATA[<p>对元素使用clear属性时，表示清除元素周围的浮动。</p>
<p>clear清除浮动时，<strong>对添加clear属性的元素本身起作用</strong>。比如:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="undefined">	div&#123;</span></div><div class="line"><span class="undefined">		width: 100px;</span></div><div class="line"><span class="undefined">		height: 100px;</span></div><div class="line"><span class="undefined">		background: red;</span></div><div class="line"><span class="undefined">		float: left;</span></div><div class="line"><span class="undefined">	&#125;</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"clear:both;"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p>对1号元素添加clear属性并不起作用，1和2两个块还是在同一行，向左浮动，因为1号元素前面没有其他元素。</p>
<p>只有对2号元素使用clear时<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"clear:both;"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>2号元素换行。</p>
<p><strong>只对前面的代码起作用</strong>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="undefined">	div&#123;</span></div><div class="line"><span class="undefined">		width: 100px;</span></div><div class="line"><span class="undefined">		height: 100px;</span></div><div class="line"><span class="undefined">		background: red;</span></div><div class="line"><span class="undefined">		float: left;</span></div><div class="line"><span class="undefined">	&#125;</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"clear:both;"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>三个元素均设置为向左浮动，为中间的元素添加 <strong>clear:both</strong>，<strong>div3</strong>还是和 <strong>div2</strong>在一行，因为clear只对前面的代码起作用所以2号元素换行后还是和3号元素在一起。</p>
<p>技巧:所有使用<strong>clear:left</strong>或者<strong>clear:right</strong>的地方都可以使用<strong>clear</strong>代替。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对元素使用clear属性时，表示清除元素周围的浮动。&lt;/p&gt;
&lt;p&gt;clear清除浮动时，&lt;strong&gt;对添加clear属性的元素本身起作用&lt;/strong&gt;。比如:&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;style&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;undefined&quot;&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;undefined&quot;&gt;	div&amp;#123;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;undefined&quot;&gt;		width: 100px;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;undefined&quot;&gt;		height: 100px;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;undefined&quot;&gt;		background: red;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;undefined&quot;&gt;		float: left;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;undefined&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;undefined&quot;&gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;style&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;style&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;clear:both;&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;1&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;2&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="css" scheme="https://stevens1995.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://stevens1995.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript getter and setter</title>
    <link href="https://stevens1995.github.io/2017/05/07/javaScript%20getter%20and%20setter/"/>
    <id>https://stevens1995.github.io/2017/05/07/javaScript getter and setter/</id>
    <published>2017-05-07T03:22:41.000Z</published>
    <updated>2017-08-28T14:16:10.599Z</updated>
    
    <content type="html"><![CDATA[<p>javaScript getter and setter</p>
<p>For the most part, in JavaScript, what you see is what you get. A value’s a value; there are no tricks. Sometimes however, you want a value that’s based on some other values: someone’s full name, for example, is a concatenation of their first and last names. If you have a person object, and you want the users of that object to be able to set the full, first or last name, and see that change immediately reflected in the other values, you’d conventionally build it with functions:</p>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">person.setLastName(<span class="string">'Smith'</span>); </div><div class="line">person.setFirstName(<span class="string">'Jimmy'</span>); </div><div class="line">person.getFullName(); <span class="comment">// Jimmy Smith</span></div></pre></td></tr></table></figure>
<p>But this is ugly, and requires the users of your object to care that the properties are related; in a more complex example, that might not be as obvious as with names. Luckily, there’s a better way, added in ECMAScript 5.</p>
<p>Meet getters and setters.</p>
<p>How</p>
<p>Let’s make that person object. We want to be able to set the first name, last name or full name, and have it update the other two automagically.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    firstName: <span class="string">'Jimmy'</span>,</div><div class="line">    lastName: <span class="string">'Smith'</span>,</div><div class="line">    get fullName() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName;</div><div class="line">    &#125;,</div><div class="line">    set fullName (name) &#123;</div><div class="line">        <span class="keyword">var</span> words = name.toString().split(<span class="string">' '</span>);</div><div class="line">        <span class="keyword">this</span>.firstName = words[<span class="number">0</span>] || <span class="string">''</span>;</div><div class="line">        <span class="keyword">this</span>.lastName = words[<span class="number">1</span>] || <span class="string">''</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">person.fullName = <span class="string">'Jack Franklin'</span>;</div><div class="line"><span class="built_in">console</span>.log(person.firstName); <span class="comment">// Jack</span></div><div class="line"><span class="built_in">console</span>.log(person.lastName) <span class="comment">// Franklin</span></div></pre></td></tr></table></figure>
<p>So what’s going on here?</p>
<p>The get and set keywords are important. Following them is the property they relate to (fullName) and a function body that defines the behaviour when the property is accessed (name = person.fullName) or modified (person.fullName = ‘Some Name’).</p>
<p>These two keywords define accessor functions: a getter and a setter for the fullName property. When the property is accessed, the return value from the getter is used. When a value is set, the setter is called and passed the value that was set. It’s up to you what you do with that value, but what is returned from the setter is the value that was passed in – so you don’t need to return anything.</p>
<p>The official way: Object.defineProperty</p>
<p>Along with the inline method of declaring getters and setters, it can also be done more explicitly via Object.defineProperty (MDN Documentation). This method takes three arguments. The first is the object to add the property to, the second is the name of the property, and the third is an object that describes the property (known as the property’s descriptor). Here’s an example that replicates the above example:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    firstName: <span class="string">'Jimmy'</span>,</div><div class="line">    lastName: <span class="string">'Smith'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">'fullName'</span>, &#123;</div><div class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> firstName + <span class="string">' '</span> + lastName;</div><div class="line">    &#125;,</div><div class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> words = name.split(<span class="string">' '</span>);</div><div class="line">        <span class="keyword">this</span>.firstName = words[<span class="number">0</span>] || <span class="string">''</span>;</div><div class="line">        <span class="keyword">this</span>.lastName = words[<span class="number">1</span>] || <span class="string">''</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>The advantage here isn’t immediately apparent. Other than being able to add properties after creating the initial object, is there a real benefit?</p>
<p>When you define a property this way, you can do much more than just define a setter or getter. You may also pass following keys:</p>
<p>configurable (false by default): if this is true, the property’s configuration will be modifiable in future.<br>enumerable (false by default): if true, the property will appear when looping over the object (for (var key in obj)).<br>We can also define properties that don’t have explicit getters or setters:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">'age'</span>, &#123;</div><div class="line">    value: <span class="number">42</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>This will create person.age, and set it to the value 42. It’s important to note that this property isn’t writable. Calling person.age = 99 will have no effect. In this way you can create read-only properties. If a property has a value key set, it cannot have a getter or setter. Properties can have values or accessors, not both.</p>
<p>Not only that, but because the enumerable property defaults to false, this property will not appear when we loop over the object’s keys.</p>
<p>If we wanted to make a property writable, we would need to set the writable property:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">'age'</span>, &#123;</div><div class="line">    value: <span class="number">42</span>,</div><div class="line">    writable: <span class="literal">true</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Now, person.age = 99; will have the desired effect.</p>
<p>Overuse</p>
<p>Remember: just because a feature exists, it doesn’t need to be used all the time. Getters and Setters have their use cases, but don’t go over the top, or you’ll most likely end up with a design that’s confusing for those interacting with your objects. Used carefully, they’re very powerful. But with great power comes great responsibility.</p>
<p>Browser support?</p>
<p>IE9 and above have full support for Object.defineProperty, along with Safari 5+, Firefox 4+, Chrome 5+ and Opera 12+. If you’re working with Node.js, there’s full support. Don’t you just love Node?!</p>
<p>This article was authored by <a href="https://twitter.com/phuunet" target="_blank" rel="external">Tom Ashworth</a>.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;javaScript getter and setter&lt;/p&gt;
&lt;p&gt;For the most part, in JavaScript, what you see is what you get. A value’s a value; there are no tricks. Sometimes however, you want a value that’s based on some other values: someone’s full name, for example, is a concatenation of their first and last names. If you have a person object, and you want the users of that object to be able to set the full, first or last name, and see that change immediately reflected in the other values, you’d conventionally build it with functions:&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://stevens1995.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://stevens1995.github.io/tags/javascript/"/>
    
  </entry>
  
</feed>

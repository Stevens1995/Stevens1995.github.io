<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://stevens1995.github.io/"/>
  <updated>2017-09-28T13:48:31.799Z</updated>
  <id>https://stevens1995.github.io/</id>
  
  <author>
    <name>Stevens</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ES6中的Promise和异步编程</title>
    <link href="https://stevens1995.github.io/2017/09/28/ES6%E4%B8%AD%E7%9A%84Promise%E5%92%8C%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    <id>https://stevens1995.github.io/2017/09/28/ES6中的Promise和异步编程/</id>
    <published>2017-09-28T04:19:19.000Z</published>
    <updated>2017-09-28T13:48:31.799Z</updated>
    
    <content type="html"><![CDATA[<h4>ES6中的Promise和异步编程</h4>

<p>Promise是除了事件和回调函数之外，异步编程的另一种选择。</p>
<p><strong>异步编程背景</strong><br>javascript引擎是基于单线程和事件循环来构建的，一次只能执行一段代码，所以需要来监听需要执行的代码，这些代码保存在<code>job queue</code>中，当一段代码准备要执行时就会添加到<code>job queue</code>中，<code>event loop</code>是一段监听<code>job queue</code>的进程，当主程序中的代码执行完毕时，<code>event loop</code>检查<code>job queue</code>是否还有代码需要执行。</p>
<p><code>事件模型</code><br>当用户点击鼠标或者按下键盘时，触发一个事件，事件相对应的处理程序便会添加到<code>job queue</code>中，这是javascript中最基础的异步编程方式。在这种模式下，代码必须跟踪处理程序所对应的对象，当情况很复杂的时候，跟踪对象也变得愈发艰难。   </p>
<p><code>回调函数</code><br>回调函数的一个最主要的问题就是<code>callback hell</code>，比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">method1(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (err) &#123;</div><div class="line">        <span class="keyword">throw</span> err;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    method2(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (err) &#123;</div><div class="line">            <span class="keyword">throw</span> err;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        method3(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (err) &#123;</div><div class="line">                <span class="keyword">throw</span> err;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            method4(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (err) &#123;</div><div class="line">                    <span class="keyword">throw</span> err;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                method5(result);</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">        &#125;);</div><div class="line"></div><div class="line">    &#125;);</div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><strong>Promise基础</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;ES6中的Promise和异步编程&lt;/h4&gt;

&lt;p&gt;Promise是除了事件和回调函数之外，异步编程的另一种选择。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异步编程背景&lt;/strong&gt;&lt;br&gt;javascript引擎是基于单线程和事件循环来构建的，一次只能执行一段代码，所以需要
    
    </summary>
    
    
      <category term="ES6" scheme="https://stevens1995.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>浏览器同源策略及规避方法</title>
    <link href="https://stevens1995.github.io/2017/09/27/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E5%8F%8A%E8%A7%84%E9%81%BF%E6%96%B9%E6%B3%95/"/>
    <id>https://stevens1995.github.io/2017/09/27/浏览器同源策略及规避方法/</id>
    <published>2017-09-27T06:58:08.000Z</published>
    <updated>2017-09-28T08:23:48.667Z</updated>
    
    <content type="html"><![CDATA[<p></p><h4>浏览器同源策略以及规避方法</h4><br>转载自<code>阮一峰</code><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="external">浏览器同源策略以及规避方法</a><br>同源策略：最初的含义是A网页设置的cookie，B网页不能打开，除非这两个网页同源，同源指的是这三个相同<p></p>
<p><ul><br>    <li>协议相同</li><br>    <li>域名相同</li><br>    <li>端口相同</li><br></ul><br>非同源间的限制：</p>
<p><ul><br>    <li>cookie、session、IndexDB无法访问</li><br>    <li>DOM无法获得</li><br>    <li>AJAX请求不能发送</li><br></ul><br><a id="more"></a></p>
<p></p><h4>规避方法:</h4><br><strong>cookie</strong><br><strong>iframe</strong><br><strong>AJAX</strong><br>同源策略中，AJAX只能发送给同源的网址，否则就会报错。<br>解决的方法有四种：  <p></p>
<ol><br>    <li>架设代理服务器（浏览器请求同源服务器，再由后者请求外部服务。）</li><br>    <li>JSONP</li><br>    <li>WebScoket</li><br>    <li>CORS</li><br></ol>

<p><em>JSONP</em><br><code>script</code>元素发出的请求不受同源策略的限制，<code>JSONP</code>正是利用了这点：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addScriptTag</span>(<span class="params">src</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</div><div class="line">  script.setAttribute(<span class="string">"type"</span>,<span class="string">"text/javascript"</span>);</div><div class="line">  script.src = src;</div><div class="line">  <span class="built_in">document</span>.body.appendChild(script);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  addScriptTag(<span class="string">'http://example.com/ip?callback=foo'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Your public IP address is: '</span> + data.ip);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><em>WebSocket</em><br>WebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">GET /chat HTTP/1.1</div><div class="line">Host: server.example.com</div><div class="line">Upgrade: websocket</div><div class="line">Connection: Upgrade</div><div class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==</div><div class="line">Sec-WebSocket-Protocol: chat, superchat</div><div class="line">Sec-WebSocket-Version: 13</div><div class="line">Origin: http://example.com</div></pre></td></tr></table></figure>
<p>上面代码中，有一个字段是Origin，表示该请求的请求源（origin），即发自哪个域名。<br>正是因为有了Origin这个字段，所以WebSocket才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 101 Switching Protocols</div><div class="line">Upgrade: websocket</div><div class="line">Connection: Upgrade</div><div class="line">Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=</div><div class="line">Sec-WebSocket-Protocol: chat</div></pre></td></tr></table></figure>
<p><em>CORS</em><br>CORS(Cross Origin Resource Share) 跨域资源共享<br>CORS允许浏览器向非同源服务器发送AJAX请求，从而突破同源策略的限制。<br>CORS需要浏览器和服务器同时支持，对于开发者来说，CORS通信和普通的AJAX通信没有区别，代码完全一样。浏览器一旦发现请求跨域，就会自动添加一些头信息，有时会多发一次请求。</p>
<p>CORS请求分为两种，<code>简答请求</code>和<code>非简答请求</code>，同满足下面两个条件的是简单请求。<br><strong>简单请求：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">（1) 请求方法是以下三种方法之一：</div><div class="line">HEAD</div><div class="line">GET</div><div class="line">POST</div><div class="line">（2）HTTP的头信息不超出以下几种字段：</div><div class="line">Accept</div><div class="line">Accept-Language</div><div class="line">Content-Language</div><div class="line">Last-Event-ID</div><div class="line">Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</div></pre></td></tr></table></figure></p>
<p>对于简单请求，浏览器直接发出CORS请求。具体来说就是在头部加一个origin字段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">GET /cors HTTP/1.1</div><div class="line">Origin: http://api.bob.com</div><div class="line">Host: api.alice.com</div><div class="line">Accept-Language: en-US</div><div class="line">Connection: keep-alive</div><div class="line">User-Agent: Mozilla/5.0...</div></pre></td></tr></table></figure></p>
<p>上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。<br>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段（详见下文），就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。<br>如果<code>Origin</code>指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Origin: http://api.bob.com</div><div class="line">Access-Control-Allow-Credentials: true</div><div class="line">Access-Control-Expose-Headers: FooBar</div><div class="line">Content-Type: text/html; charset=utf-8</div></pre></td></tr></table></figure></p>
<p>上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。<br><strong>（1）Access-Control-Allow-Origin</strong><br>该字段是必须的。他的值要么是请求是Origin字段的值，要么是一个<em>，表示接受任何域名的请求<br><strong>（2）Access-Control-Allow-Credentials</strong><br>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。<br><em>*（3）Access-Control-Expose-Headers</em></em><br>该字段可选。CORS请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type、Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。上面的例子指定，<code>getResponseHeader(&#39;FooBar&#39;)</code>  可以返回<code>FooBar</code>字段的值。<br><strong>withCredentials 属性</strong><br>上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Credentials: true</div></pre></td></tr></table></figure></p>
<p>另一方面，开发者必须在AJAX请求中打开<code>withCredentials</code>属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var xhr = new XMLHttpRequest();</div><div class="line">xhr.withCredentials = true;</div></pre></td></tr></table></figure></p>
<p>否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。<br>但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xhr.withCredentials = false;</div></pre></td></tr></table></figure></p>
<p>需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。<br><strong>非简单请求：</strong><br><strong><em>4.1 预检请求</em></strong><br>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。<br>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。<br>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> url = <span class="string">'http://api.alice.com/cors'</span>;</div><div class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">xhr.open(<span class="string">'PUT'</span>, url, <span class="literal">true</span>);</div><div class="line">xhr.setRequestHeader(<span class="string">'X-Custom-Header'</span>, <span class="string">'value'</span>);</div><div class="line">xhr.send();</div></pre></td></tr></table></figure></p>
<p>上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。<br>浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的HTTP头信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">OPTIONS /cors HTTP/1.1</div><div class="line">Origin: http://api.bob.com</div><div class="line">Access-Control-Request-Method: PUT</div><div class="line">Access-Control-Request-Headers: X-Custom-Header</div><div class="line">Host: api.alice.com</div><div class="line">Accept-Language: en-US</div><div class="line">Connection: keep-alive</div><div class="line">User-Agent: Mozilla/5.0...</div></pre></td></tr></table></figure></p>
<p>“预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。<br>除了Origin字段，”预检”请求的头信息包括两个特殊字段。<br><strong>（1）Access-Control-Request-Method</strong><br>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。<br><strong>（2）Access-Control-Request-Headers</strong><br>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。<br><strong><em>4.2 预检请求的回应 </em></strong><br>服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Date: Mon, 01 Dec 2008 01:15:39 GMT</div><div class="line">Server: Apache/2.0.61 (Unix)</div><div class="line">Access-Control-Allow-Origin: http://api.bob.com</div><div class="line">Access-Control-Allow-Methods: GET, POST, PUT</div><div class="line">Access-Control-Allow-Headers: X-Custom-Header</div><div class="line">Content-Type: text/html; charset=utf-8</div><div class="line">Content-Encoding: gzip</div><div class="line">Content-Length: 0</div><div class="line">Keep-Alive: timeout=2, max=100</div><div class="line">Connection: Keep-Alive</div><div class="line">Content-Type: text/plain</div></pre></td></tr></table></figure></p>
<p>上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示<code>http://api.bob.com</code>可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Origin: *</div></pre></td></tr></table></figure></p>
<p>如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">XMLHttpRequest cannot load http://api.alice.com.</div><div class="line">Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.</div></pre></td></tr></table></figure></p>
<p>服务器回应的其他CORS相关字段如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Access-Control-Allow-Methods: GET, POST, PUT</div><div class="line">Access-Control-Allow-Headers: X-Custom-Header</div><div class="line">Access-Control-Allow-Credentials: true</div><div class="line">Access-Control-Max-Age: 1728000</div></pre></td></tr></table></figure></p>
<p><strong><em>（1）Access-Control-Allow-Methods</em></strong><br>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。<br><strong><em>（2）Access-Control-Allow-Headers</em></strong><br>如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。<br><strong><em>（3）Access-Control-Allow-Credentials</em></strong><br>该字段与简单请求时的含义相同。<br><strong><em>（4）Access-Control-Max-Age</em></strong><br>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。<br><strong>4.3 浏览器的正常请求和回应</strong><br>一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。<br>下面是”预检”请求之后，浏览器的正常CORS请求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">PUT /cors HTTP/1.1</div><div class="line">Origin: http://api.bob.com</div><div class="line">Host: api.alice.com</div><div class="line">X-Custom-Header: value</div><div class="line">Accept-Language: en-US</div><div class="line">Connection: keep-alive</div><div class="line">User-Agent: Mozilla/5.0...</div></pre></td></tr></table></figure></p>
<p>上面头信息的Origin字段是浏览器自动添加的。<br>下面是服务器正常的回应。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Origin: http://api.bob.com</div><div class="line">Content-Type: text/html; charset=utf-8</div></pre></td></tr></table></figure></p>
<p>上面头信息中，Access-Control-Allow-Origin字段是每次回应都必定包含的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;h4&gt;浏览器同源策略以及规避方法&lt;/h4&gt;&lt;br&gt;转载自&lt;code&gt;阮一峰&lt;/code&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/04/cors.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;浏览器同源策略以及规避方法&lt;/a&gt;&lt;br&gt;同源策略：最初的含义是A网页设置的cookie，B网页不能打开，除非这两个网页同源，同源指的是这三个相同&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;ul&gt;&lt;br&gt;    &lt;li&gt;协议相同&lt;/li&gt;&lt;br&gt;    &lt;li&gt;域名相同&lt;/li&gt;&lt;br&gt;    &lt;li&gt;端口相同&lt;/li&gt;&lt;br&gt;&lt;/ul&gt;&lt;br&gt;非同源间的限制：&lt;/p&gt;
&lt;p&gt;&lt;ul&gt;&lt;br&gt;    &lt;li&gt;cookie、session、IndexDB无法访问&lt;/li&gt;&lt;br&gt;    &lt;li&gt;DOM无法获得&lt;/li&gt;&lt;br&gt;    &lt;li&gt;AJAX请求不能发送&lt;/li&gt;&lt;br&gt;&lt;/ul&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>网站性能优化相关</title>
    <link href="https://stevens1995.github.io/2017/09/27/%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3/"/>
    <id>https://stevens1995.github.io/2017/09/27/网站性能优化相关/</id>
    <published>2017-09-27T02:33:18.000Z</published>
    <updated>2017-09-27T10:07:36.555Z</updated>
    
    <content type="html"><![CDATA[<h4>网页性能相关</h4>

<p>转载自<code>阮一峰</code>的<a href="http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html" target="_blank" rel="external">网页性能管理详解</a></p>
<p></p><h4>1.网页的生成过程</h4><br>要理解网站性能为何不好，首先需要了解网页是怎么生成的。<br>网页的生成过程大致可以分为以下五个步骤:<br><a id="more"></a><p></p>
<p><ol><br>    <li>html代码转化成DOM</li><br>    <li>CSS代码转化成CSSOM</li><br>    <li>结合DOM和CSSOM生成一棵渲染树</li><br>    <li>生成布局（layout）</li><br>    <li>将布局绘制在屏幕上</li><br></ol><br><img src="https://raw.githubusercontent.com/Stevens1995/blogImages/master/20170927/pageGeneration.png" alt=""><br>其中，第一步到第三步都非常快，最后两步耗时较多。<br>生成布局(flow)和绘制(paint)这两步合成为’渲染’(render)</p>
<p></p><h4>2.重绘（repaint）和重排（reflow）</h4><br>网站生成的时候会至少渲染一次，用户访问的过程中还会不断的重新渲染。<br>以下3中情况会导致页面重新渲染：<p></p>
<ul><br>    <li>修改DOM</li><br>    <li>修改样式表</li><br>    <li>用户事件（比如鼠标悬停、页面滚动、输入框键入文字、改变窗口大小等等）</li><br></ul>

<p>因为<code>reflow</code>在<code>repaint</code>前面发生，所以<code>reflow</code>一定会导致<code>repaint</code>，但是<code>repaint</code>不一定会导致<code>reflow</code></p>
<p></p><h4>3.对于性能的影响</h4><br>重绘和重排会不断地触发，这是不可避免的，要提高网页的性能就需要尽量降低重新渲染的频率。<p></p>
<p></p><h4>提高性能的几个技巧</h4><p></p>
<ul><br>    <li>写操作应该放在一起，不要几个读操作中间加一个写操作。</li><br>    <li>缓存，如果某个样式是通过重排得到的，最好缓存一下。</li><br>    <li>不要一条一条地改变样式，通过增加和删除class来一组一组地改变样式</li><br>    <li>同上，可以通过fragement来一组一组地改变DOM，避免频繁地改变真实的DOM</li><br>    <li>display属性为none的元素不会触发渲染，所以对某个元素进行多次操作前可以先设为display:none;然后再更改。</li><br>    <li>visibility:hidden;的元素只对重绘有影响，不会影响重排</li><br>    <li>虚拟DOM，比如Vue.js、React.js</li><br>    <li>window.requestAnimationFrame()、window.requestIdleCallback() </li><br></ul>

]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;网页性能相关&lt;/h4&gt;

&lt;p&gt;转载自&lt;code&gt;阮一峰&lt;/code&gt;的&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;网页性能管理详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;h4&gt;1.网页的生成过程&lt;/h4&gt;&lt;br&gt;要理解网站性能为何不好，首先需要了解网页是怎么生成的。&lt;br&gt;网页的生成过程大致可以分为以下五个步骤:&lt;br&gt;
    
    </summary>
    
    
      <category term="web" scheme="https://stevens1995.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>ES6中关于Object的扩展</title>
    <link href="https://stevens1995.github.io/2017/09/27/ES6%E4%B8%AD%E5%85%B3%E4%BA%8EObject%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>https://stevens1995.github.io/2017/09/27/ES6中关于Object的扩展/</id>
    <published>2017-09-27T02:11:00.000Z</published>
    <updated>2017-09-28T04:36:40.279Z</updated>
    
    <content type="html"><![CDATA[<h4>ES6中的Promise和异步编程</h4><br><code>Promise</code>是除了事件和回调函数之后的另一种异步编程的选择。<br><br><h4>异步编程的背景</h4>

<p><strong>事件模型</strong></p>
<p>__</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;ES6中的Promise和异步编程&lt;/h4&gt;&lt;br&gt;&lt;code&gt;Promise&lt;/code&gt;是除了事件和回调函数之后的另一种异步编程的选择。&lt;br&gt;&lt;br&gt;&lt;h4&gt;异步编程的背景&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;事件模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;__&lt;/p&gt;

    
    </summary>
    
    
      <category term="ES6" scheme="https://stevens1995.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6中的Function扩展</title>
    <link href="https://stevens1995.github.io/2017/09/26/ES6%E4%B8%AD%E7%9A%84Function%E6%89%A9%E5%B1%95/"/>
    <id>https://stevens1995.github.io/2017/09/26/ES6中的Function扩展/</id>
    <published>2017-09-26T07:48:07.000Z</published>
    <updated>2017-09-27T02:13:07.051Z</updated>
    
    <content type="html"><![CDATA[<h4>ES6中有关函数的扩展</h4>

<h4>1.带有默认参数值的函数</h4>

<p>在ES5中，想要为函数带上默认参数一般采用下面这种做法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRequest</span>(<span class="params">url, timeout, callback</span>) </span>&#123;</div><div class="line"></div><div class="line">    timeout = timeout || <span class="number">2000</span>;</div><div class="line">    callback = callback || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"></div><div class="line">    <span class="comment">// the rest of the function</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>上面的做法存在一种缺陷，就是当参数值设为0的时候，<code>||</code>运算符会将<code>0</code>转换为false，从而采用默认值。在ES5中的解决方法是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRequest</span>(<span class="params">url, timeout, callback</span>) </span>&#123;</div><div class="line"></div><div class="line">    timeout = (<span class="keyword">typeof</span> timeout !== <span class="string">"undefined"</span>) ? timeout : <span class="number">2000</span>;</div><div class="line">    callback = (<span class="keyword">typeof</span> callback !== <span class="string">"undefined"</span>) ? callback : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"></div><div class="line">    <span class="comment">// the rest of the function</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种做法很有效，但是依然需要占用多余的空间，并且代码不简洁，在ES6中的做法是：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRequest</span>(<span class="params">url, timeout = <span class="number">2000</span>, callback = function(</span>) </span>&#123;&#125;) &#123;</div><div class="line"></div><div class="line">    <span class="comment">// the rest of the function</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当传入的参数时<code>undefined</code>时，函数将采用默认值，传入<code>null</code>时认为<code>null</code>合法，不会采用默认值：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a=<span class="number">1</span>,b</span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(a);</div><div class="line">&#125;</div><div class="line"></div><div class="line">test(<span class="literal">undefined</span>,<span class="number">1</span>); <span class="comment">//1</span></div><div class="line">test(<span class="literal">null</span>,<span class="number">1</span>); <span class="comment">//null</span></div></pre></td></tr></table></figure></p>
<p><em>ES6中arguments对象与默认值的联系</em></p>
<p>在非严格模式中，<code>arguments</code>对象会随着变量值的改变而自动更新，所以<code>arguments</code>中的值与参数一直相等<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixArgs</span>(<span class="params">first, second</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>]);</div><div class="line">    <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>]);</div><div class="line">    first = <span class="string">"c"</span>;</div><div class="line">    second = <span class="string">"d"</span>;</div><div class="line">    <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>]);</div><div class="line">    <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">mixArgs(<span class="string">"a"</span>, <span class="string">"b"</span>);</div></pre></td></tr></table></figure></p>
<p>输出结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">true</div><div class="line">true</div><div class="line">true</div><div class="line">true</div></pre></td></tr></table></figure></p>
<p>在严格模式下，<code>arguments</code>对象不会随着有默认值的变量的改变而改变:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixArgs</span>(<span class="params">first, second</span>) </span>&#123;</div><div class="line"><span class="meta">    "use strict"</span>;</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>]);</div><div class="line">    <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>]);</div><div class="line">    first = <span class="string">"c"</span>;</div><div class="line">    second = <span class="string">"d"</span></div><div class="line">    <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>]);</div><div class="line">    <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">mixArgs(<span class="string">"a"</span>, <span class="string">"b"</span>);</div></pre></td></tr></table></figure></p>
<p>输出结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">true</div><div class="line">true</div><div class="line">false</div><div class="line">false</div></pre></td></tr></table></figure></p>
<p>在带有默认值的参数的函数中，<code>arguments</code>对象会始终以严格模式运行，并且带有默认值的参数会始终与<code>arguments</code>对象保持分离:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// not in strict mode</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixArgs</span>(<span class="params">first, second = <span class="string">"b"</span></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);</div><div class="line">    <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>]);</div><div class="line">    <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>]);</div><div class="line">    first = <span class="string">"c"</span>;</div><div class="line">    second = <span class="string">"d"</span></div><div class="line">    <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>]);</div><div class="line">    <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">mixArgs(<span class="string">"a"</span>);</div></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line">true</div><div class="line">false</div><div class="line">false</div><div class="line">false</div></pre></td></tr></table></figure></p>
<p>因为只传入了一个参数，所以<code>arguments</code>对象的长度始终为1，并且始终与带有默认值的参数保持分离。</p>
<p><em>默认值为表达式的参数</em><br>函数参数的默认值不一定是基本类型，还可以是表达式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">5</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first, second = getValue(</span>)) </span>&#123;</div><div class="line">    <span class="keyword">return</span> first + second;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>));     <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>));        <span class="comment">// 6</span></div></pre></td></tr></table></figure></p>
<p>当函数没有传入第二个参数时，getValue()函数便会执行返回一值赋给第二个参数。</p>
<p>因为能为函数的参数值设置表达式，所以也可以将前面的参数设置为后面参数的默认值：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first, second = first</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> first + second;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>));     <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>));        <span class="comment">// 2</span></div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">函数的参数有自己的作用域和TDZ（暂时性死区），这意味着函数参数不能访问函数体内的变量和声明</div></pre></td></tr></table></figure>
<h4>2.未命名参数的使用</h4><br>前面讲的是已命名参数的使用，这种情况适用于传入函数的参数个数小于期望的个数，未命名参数则使用于传入比默认参数更多数量的情况。<br><br>在ES5中使用未命名参数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">object</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> result = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line"></div><div class="line">    <span class="comment">// start at the second parameter</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</div><div class="line">        result[<span class="built_in">arguments</span>[i]] = object[<span class="built_in">arguments</span>[i]];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> book = &#123;</div><div class="line">    title: <span class="string">"Understanding ECMAScript 6"</span>,</div><div class="line">    author: <span class="string">"Nicholas C. Zakas"</span>,</div><div class="line">    year: <span class="number">2015</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> bookData = pick(book, <span class="string">"author"</span>, <span class="string">"year"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(bookData.author);   <span class="comment">// "Nicholas C. Zakas"</span></div><div class="line"><span class="built_in">console</span>.log(bookData.year);     <span class="comment">// 2015</span></div></pre></td></tr></table></figure><br><br>在ES6中使用未命名参数：<br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">object, ...keys</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> result = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = keys.length; i &lt; len; i++) &#123;</div><div class="line">        result[keys[i]] = object[keys[i]];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>这个函数和在ES5中实现的功能一样，通过<code>...</code>运算符，所有的除了期望的参数之外的多出来的参数都被保存到<code>keys</code>数组中（类似于<code>arguments</code>对象，只不过<code>arguments</code>对象保存了所有的参数）<br><br><em>函数有一个<code>length</code>属性，代表着函数参数中有默认值的参数个数，多余的参数不会影响<code>length</code>的值</em><br><br>用法限制：<br><code>...keys</code>这种能用只能用在参数的最后面，下面这种用法将会报错：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Syntax error: Can't have a named parameter after rest parameters</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">object, ...keys, last</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> result = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = keys.length; i &lt; len; i++) &#123;</div><div class="line">        result[keys[i]] = object[keys[i]];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>第二个限制是不能用在对象的<code>set</code>函数中，下面的用法也会报错：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> object = &#123;</div><div class="line"></div><div class="line">    <span class="comment">// Syntax error: Can't use rest param in setter</span></div><div class="line">    set name(...value) &#123;</div><div class="line">        <span class="comment">// do something</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><br><br><br><code>rest paraments</code>对<code>arguments</code>对象的影响：<br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkArgs</span>(<span class="params">...args</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(args.length);</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);</div><div class="line">    <span class="built_in">console</span>.log(args[<span class="number">0</span>], <span class="built_in">arguments</span>[<span class="number">0</span>]);</div><div class="line">    <span class="built_in">console</span>.log(args[<span class="number">1</span>], <span class="built_in">arguments</span>[<span class="number">1</span>]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">checkArgs(<span class="string">"a"</span>, <span class="string">"b"</span>);</div></pre></td></tr></table></figure><br><br>输出结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">2</div><div class="line">2</div><div class="line">a a</div><div class="line">b b</div></pre></td></tr></table></figure><br><br><code>arguments</code>对象总是能够正确地映射所有的参数，与<code>rest paraments</code>无关。<br><br><h4>3.<code>Function</code>函数的扩展</h4>

<p>通常不使用<code>Function</code>函数来创造一个新函数，但是ES6中也对<code>Function</code>函数进行了扩展。<br>ES5中的用法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> add = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"first"</span>, <span class="string">"second"</span>, <span class="string">"return first + second"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>));     <span class="comment">// 2</span></div></pre></td></tr></table></figure></p>
<p>ES6中允许使用默认的函数值和<code>...</code>操作符</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> add = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"first"</span>, <span class="string">"second = first"</span>,</div><div class="line">        <span class="string">"return first + second"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>));     <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>));        <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> pickFirst = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"...args"</span>, <span class="string">"return args[0]"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(pickFirst(<span class="number">1</span>, <span class="number">2</span>));   <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<h4>4.The Spread Operator(扩展操作符)</h4><br>与<code>rest paraments</code>相关，<code>rest paraments</code>将多余的参数合并为一个数组，<code>...</code>扩展操作符将一个数组分隔成多个参数传入函数<br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> values = [<span class="number">25</span>, <span class="number">50</span>, <span class="number">75</span>, <span class="number">100</span>]</div><div class="line"></div><div class="line"><span class="comment">// equivalent to</span></div><div class="line"><span class="comment">// console.log(Math.max(25, 50, 75, 100));</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...values));     <span class="comment">// 100</span></div></pre></td></tr></table></figure><br><br><h4>5.ES6中的name属性</h4><br>ES6中，所有的函数都有一个<code>name</code>属性:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> doAnotherThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(doSomething.name);          <span class="comment">// "doSomething"</span></div><div class="line"><span class="built_in">console</span>.log(doAnotherThing.name);       <span class="comment">// "doAnotherThing"</span></div></pre></td></tr></table></figure><br><br><em>有关name属性的特殊案例</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span> <span class="title">doSomethingElse</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    get firstName() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Nicholas"</span></div><div class="line">    &#125;,</div><div class="line">    sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(doSomething.name);      <span class="comment">// "doSomethingElse"</span></div><div class="line"><span class="built_in">console</span>.log(person.sayName.name);   <span class="comment">// "sayName"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">"firstName"</span>);</div><div class="line"><span class="built_in">console</span>.log(descriptor.get.name); <span class="comment">// "get firstName"</span></div></pre></td></tr></table></figure><br><br><code>get</code>和<code>set</code>函数的前面都会带上get或者set（要去的访问器属性，必须使用Object.getOwnPropertyDescriptor()函数）<br><br>一些其他的特殊案例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(doSomething.bind().name);   <span class="comment">// "bound doSomething"</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log((<span class="keyword">new</span> <span class="built_in">Function</span>()).name);     <span class="comment">// "anonymous"</span></div></pre></td></tr></table></figure><br><br>使用<code>bind()</code>绑定的函数name属性前有一个<code>bound</code><br>使用<code>Function()</code>构造的函数name属性为<code>anonymous</code><br><br><h4>6.函数的双重用法</h4>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>);</div><div class="line"><span class="keyword">var</span> notAPerson = Person(<span class="string">"Nicholas"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person);        <span class="comment">// "[Object object]"</span></div><div class="line"><span class="built_in">console</span>.log(notAPerson);    <span class="comment">// "undefined"</span></div></pre></td></tr></table></figure>
<p>javascript函数有两个内部方法，<code>[[call]]</code>和<code>[[constructor]]</code>，当函数不用<code>new</code>关键字调用时，[[call]]方法运行，执行函数体中的方法。当函数使用<code>new</code>关键字时，[[constructor]]方法调用，创造一个新对象，成为<code>new target</code>，然后将函数的<code>this</code>指向新对象，运行函数体。</p>
<p><em>并不是所有的函数都有[[constructor]]方法，比如箭头函数就没有</em></p>
<p>在ES5中，要判断和决定函数用那种方法运行，需要使用this：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Person) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;   <span class="comment">// using new</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"You must use new with Person."</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>);</div><div class="line"><span class="keyword">var</span> notAPerson = Person(<span class="string">"Nicholas"</span>);  <span class="comment">// throws error</span></div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Person) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;   <span class="comment">// using new</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"You must use new with Person."</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>);</div><div class="line"><span class="keyword">var</span> notAPerson = Person.call(person, <span class="string">"Michael"</span>);    <span class="comment">// works!</span></div></pre></td></tr></table></figure>
<p>ES6中的方法，<code>new.target</code>属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">new</span>.target !== <span class="string">"undefined"</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;   <span class="comment">// using new</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"You must use new with Person."</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>);</div><div class="line"><span class="keyword">var</span> notAPerson = Person.call(person, <span class="string">"Michael"</span>);    <span class="comment">// error!</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.target === Person) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;   <span class="comment">// using new</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"You must use new with Person."</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">AnotherPerson</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    Person.call(<span class="keyword">this</span>, name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>);</div><div class="line"><span class="keyword">var</span> anotherPerson = <span class="keyword">new</span> AnotherPerson(<span class="string">"Nicholas"</span>);  <span class="comment">// error!</span></div></pre></td></tr></table></figure>
<p>当[[constructor]]方法执行时，new.target被送进执行的函数中，指向新创建的作为函数的<code>this</code>的对象。</p>
<p></p><h4>7.块级函数</h4><br>在ES5中，下面的代码将会报错：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line"></div><div class="line">    <span class="comment">// Throws a syntax error in ES5, not so in ES6</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p>
<p>但是在ES6中，<code>doSomething()</code>函数被考虑为块级作用域函数，能在作用域内访问：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> doSomething);        <span class="comment">// "function"</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    doSomething();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> doSomething);            <span class="comment">// "undefined"</span></div></pre></td></tr></table></figure></p>
<p></p><h4>8.箭头函数</h4><br>箭头函数与普通javascript函数的重要区别：<p></p>
<ul><br>    <li>没有<code>this</code>、<code>arguments</code>、<code>new.target</code>绑定</li><br>    <li>不能用<code>new</code>来调用(因为内部没有[[constructor]]方法)</li><br>    <li>没有<code>prototype</code></li><br>    <li>不能改变<code>this</code></li><br>    <li>没有<code>arguments</code>对象</li><br>    <li>No duplicate named parameters</li><br></ul>

<p><em>注意：箭头函数同样也有<code>name</code>属性</em></p>
<p><em>箭头函数的语法</em><br>箭头函数最简单的写法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> reflect = <span class="function"><span class="params">value</span> =&gt;</span> value;</div><div class="line"></div><div class="line"><span class="comment">// effectively equivalent to:</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> reflect = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>当函数不止一个参数时，需要将参数用<code>()</code>包括起来。<br>当函数体内没有操作，或者你想添加更多的操作时，又或者函数需要返回一个对象时，需要将函数体用<code>{}</code>包括起来。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// effectively equivalent to:</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">---------------------------------------------------------------------------</div><div class="line"></div><div class="line"><span class="keyword">var</span> doNothing = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">// effectively equivalent to:</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> doNothing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"></div><div class="line">---------------------------------------------------------------------------</div><div class="line"></div><div class="line"><span class="keyword">var</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> (&#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">"Temp"</span> &#125;);</div><div class="line"></div><div class="line"><span class="comment">// effectively equivalent to:</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> getTempItem = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        id: id,</div><div class="line">        name: <span class="string">"Temp"</span></div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><em>立即执行函数表达式(IIFE)</em></p>
<p>ES5中的做法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> name;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">&#125;(<span class="string">"Nicholas"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person.getName());      <span class="comment">// "Nicholas"</span></div></pre></td></tr></table></figure></p>
<p>箭头函数的版本：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> person = <span class="function">(<span class="params">(name</span>) =&gt;</span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> name;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">&#125;)(<span class="string">"Nicholas"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person.getName());      <span class="comment">// "Nicholas"</span></div></pre></td></tr></table></figure></p>
<p><em>无<code>this</code>绑定</em><br>ES5中，函数的<code>this</code>值会发生改变，这容易造成很多错误。ES6的箭头函数移除了这一点，箭头函数没有<code>this</code>绑定值，这意味着在箭头函数中调用<code>this</code>的值时会在作用域链中查找。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> PageHandler = &#123;</div><div class="line"></div><div class="line">    id: <span class="string">"123456"</span>,</div><div class="line"></div><div class="line">    init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">document</span>.addEventListener(<span class="string">"click"</span>,</div><div class="line">                event =&gt; <span class="keyword">this</span>.doSomething(event.type), <span class="literal">false</span>);</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    doSomething: <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Handling "</span> + type  + <span class="string">" for "</span> + <span class="keyword">this</span>.id);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这个例子中，<code>this</code>的值和<code>init()</code>函数中的<code>this</code>值相同</p>
<p><em>无<code>arguments</code>绑定</em></p>
<p><em>识别箭头函数</em><br>箭头函数也是函数，可以用判断一般函数的方法来判断箭头函数:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> comparator = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> comparator);                 <span class="comment">// "function"</span></div><div class="line"><span class="built_in">console</span>.log(comparator <span class="keyword">instanceof</span> <span class="built_in">Function</span>);    <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p></p><h4>尾部调用优化(Tail Call Optimization)</h4><br>在一个函数的最后一个语句调用函数，这种调用称作<code>Tail Call</code>。ES6中在严格模式下如果有尾部调用，则会进行优化，尾部调用不会创造新的执行上下文压入执行栈中，而是会重用旧函数的上下文。<p></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;ES6中有关函数的扩展&lt;/h4&gt;

&lt;h4&gt;1.带有默认参数值的函数&lt;/h4&gt;

&lt;p&gt;在ES5中，想要为函数带上默认参数一般采用下面这种做法：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;makeRequest&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;url, timeout, callback&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    timeout = timeout || &lt;span class=&quot;number&quot;&gt;2000&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    callback = callback || &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// the rest of the function&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="ES6" scheme="https://stevens1995.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6中的Set和Map</title>
    <link href="https://stevens1995.github.io/2017/09/26/ES6%E4%B8%AD%E7%9A%84Set%E5%92%8CMap/"/>
    <id>https://stevens1995.github.io/2017/09/26/ES6中的Set和Map/</id>
    <published>2017-09-26T06:27:37.000Z</published>
    <updated>2017-09-26T06:27:37.522Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HTML5新特性总结</title>
    <link href="https://stevens1995.github.io/2017/09/26/HTML5%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    <id>https://stevens1995.github.io/2017/09/26/HTML5新特性总结/</id>
    <published>2017-09-26T03:04:40.000Z</published>
    <updated>2017-09-26T03:04:40.477Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSS3新特性总结</title>
    <link href="https://stevens1995.github.io/2017/09/26/CSS3%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    <id>https://stevens1995.github.io/2017/09/26/CSS3新特性总结/</id>
    <published>2017-09-26T03:04:00.000Z</published>
    <updated>2017-09-28T04:14:58.200Z</updated>
    
    <content type="html"><![CDATA[<p>CSS被划分为模块:  </p>
<ul><br>    <li>选择器</li><br>    <li>框模型</li><br>    <li>背景和边框</li><br>    <li>文本效果</li><br>    <li>2D/3D转换</li><br>    <li>动画</li><br>    <li>多列布局</li><br>    <li>用户界面</li><br></ul>

<p><strong>选择器</strong></p>
<p><strong>框模型</strong></p>
<p><strong>背景和边框</strong><br>边框：<code>border-radius</code>、<code>border-image</code>、<code>box-shadow</code><br>背景：<code>background-clip</code>、<code>background-origin</code> 、<code>background-size</code><br><strong>文本效果</strong><br><code>text-shadow</code>、<code>word-wrap</code><br><strong>背景和边框</strong><br><strong>文本效果</strong><br><strong>2D/3D效果</strong><br><code>transform</code>、<code>transform-origin</code><br>2D转换方法:<code>translate()</code>、<code>scale()</code>、<code>skew()</code>、<code>rotate()</code>、<code>matrix</code><br>3D转换属性:<code>transform-style</code>、<code>perspective</code>、<code>perspective-origin</code>、<code>backface-visibility</code><br><strong>动画</strong><br>过渡：<code>transition</code>（简写）、<code>transition-property</code>、<code>transition-duration</code>、<code>transition-timing-function</code>、<code>transition-delay</code><br>动画: <code>@keyframes</code>、<code>animation</code>、<code>animation-name</code>、<code>animation-duration</code>、<code>animation-timing-function</code>、<code>animation-delay</code>、<code>animation-iteration-count</code>、<code>animation-direction</code>、<code>animation-play-state</code>、<code>animation-fill-mode</code><br><strong>多列布局</strong><br><code>column-count</code>、<code>column-fill</code>、<code>column-gap</code>、<code>column-rule</code>、<code>column-span</code>、<code>column-width</code>、<code>columns</code><br><strong>用户界面</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSS被划分为模块:  &lt;/p&gt;
&lt;ul&gt;&lt;br&gt;    &lt;li&gt;选择器&lt;/li&gt;&lt;br&gt;    &lt;li&gt;框模型&lt;/li&gt;&lt;br&gt;    &lt;li&gt;背景和边框&lt;/li&gt;&lt;br&gt;    &lt;li&gt;文本效果&lt;/li&gt;&lt;br&gt;    &lt;li&gt;2D/3D转换&lt;/li&gt;&lt;br&gt;    &lt;
    
    </summary>
    
    
      <category term="CSS" scheme="https://stevens1995.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>ES6中的Iterator和generators</title>
    <link href="https://stevens1995.github.io/2017/09/25/ES6%E4%B8%AD%E7%9A%84Iterator%E5%92%8Cgenerators/"/>
    <id>https://stevens1995.github.io/2017/09/25/ES6中的Iterator和generators/</id>
    <published>2017-09-25T14:38:07.000Z</published>
    <updated>2017-09-26T03:39:13.288Z</updated>
    
    <content type="html"><![CDATA[<h4>什么是iterator</h4>

<p>iterator，迭代器，就是对象，具有一些用来迭代的接口。</p>
<h4>什么是generator</h4><br>generator是一个函数，返回一个iterator<br><br>在函数的function关键字之后，函数名之前加一个<code>*</code>号来表明函数是一个生成器。用<code>yield</code>关键字来声明返回值。迭代器和普通的for循环之间的区别是每次调用<code>next()</code>函数之后，不会继续执行，除非再次调用<code>next()</code><br><br><br><br><h4>Advanced Iterator Functionality</h4>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">```javascript</div><div class="line">function *createIterator() &#123;</div><div class="line">    let first = yield 1;</div><div class="line">    let second = yield first + 2;       // 4 + 2</div><div class="line">    yield second + 3;                   // 5 + 3</div><div class="line">&#125;</div><div class="line"></div><div class="line">let iterator = createIterator();</div><div class="line"></div><div class="line">console.log(iterator.next());           // &quot;&#123; value: 1, done: false &#125;&quot;</div><div class="line">console.log(iterator.next(4));          // &quot;&#123; value: 6, done: false &#125;&quot;</div><div class="line">console.log(iterator.next(5));          // &quot;&#123; value: 8, done: false &#125;&quot;</div><div class="line">console.log(iterator.next());           // &quot;&#123; value: undefined, done: true &#125;&quot;</div></pre></td></tr></table></figure>
<p>在这个例子中，每次向next函数中传递的参数都会成为上一个<code>yield</code>语句的返回值。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;什么是iterator&lt;/h4&gt;

&lt;p&gt;iterator，迭代器，就是对象，具有一些用来迭代的接口。&lt;/p&gt;
&lt;h4&gt;什么是generator&lt;/h4&gt;&lt;br&gt;generator是一个函数，返回一个iterator&lt;br&gt;&lt;br&gt;在函数的function关键字之后，函数
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ES6中的class</title>
    <link href="https://stevens1995.github.io/2017/09/25/ES6%E4%B8%AD%E7%9A%84class/"/>
    <id>https://stevens1995.github.io/2017/09/25/ES6中的class/</id>
    <published>2017-09-25T02:22:28.000Z</published>
    <updated>2017-09-25T14:44:31.935Z</updated>
    
    <content type="html"><![CDATA[<h4>ES5中的类结构实现:</h4>

<p>ES5中类似于类的实现是先创造一个构造函数，然后在其原型上定义方法，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">PersonType</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">PersonType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> PersonType(<span class="string">'Nicholas'</span>);</div><div class="line">person.sayName();   <span class="comment">// Nicholas</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> PersonType); <span class="comment">//true </span></div><div class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>上面这种模式是很多库实现类的基础，也是ES6中类的基础。  </p>
<h4>类声明</h4>

<p>class关键字 + 类名  花括号中的语法像是ES6中对象字面量中方法的简写，不过方法间没有逗号。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonClass</span></span>&#123;</div><div class="line">	<span class="comment">//定义类的构造函数</span></div><div class="line">	<span class="keyword">constructor</span>(name)&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	sayName()&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> PersonClass(<span class="string">'Nicholas'</span>);</div><div class="line">person.sayName();  <span class="comment">//Nicholas</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> PersonClass); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass); <span class="comment">//function</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass.prototype.sayName); <span class="comment">//function</span></div></pre></td></tr></table></figure>
<p>自有属性：对象的自有属性应该全部定义在构造函数中  </p>
<p>值得注意的是，class关键字声明只是基于现有的语法的语法糖，上面声明的PersonClass类实际上创造了一个函数，这个函数表现的和constructor构造函数一样。 所以<code>typeof PeronClass</code>是<code>function</code>，<code>sayName</code>函数和<code>constructor</code>的关系类似于上面<code>PersonType</code>和<code>sayName</code>的关系，这种类似性让我们在混合使用传统类型和ES6中的class时不需要有太多的顾虑。</p>
<p>虽然class和传统语法有类似，但也有一些很重要的区别:</p>
<ul><br>    <li>class定义不同于函数声明，不存在变量提升</li><br>    <li>class定义中自动使用严格模式</li><br>    <li>所有的方法都是不可枚举的</li><br>    <li>尝试使用<code>new</code>调用除构造函数之外的方法会报错</li><br>    <li>调用构造函数必须使用<code>new</code>关键字</li><br>    <li>尝试在类方法中修改类名会报错</li><br></ul>

<p>记住这些后，上面的类声明完全可以用下面的代码代替：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> PersonClass = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="meta">	'use strict'</span></div><div class="line">	<span class="keyword">const</span> PersonClass = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">		<span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">new</span>.target === <span class="string">'undefined'</span>)&#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Constructor must be called with new."</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">Object</span>.defineProperty(PersonType2.prototype,<span class="string">"sayName"</span>,&#123;</div><div class="line">		value:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">new</span>.target !== <span class="string">'undefined'</span>)&#123;</div><div class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Method cannot be call with new.'</span>);</div><div class="line">			&#125; </div><div class="line">			<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">		&#125;</div><div class="line">		enumerable:<span class="literal">false</span>,</div><div class="line">		writable:<span class="literal">true</span>,</div><div class="line">		configurable:<span class="literal">true</span></div><div class="line">	&#125;);</div><div class="line">	<span class="keyword">return</span> PersonClass;</div><div class="line">&#125;())</div></pre></td></tr></table></figure></p>
<p>通过let和const来保证不能从内部但是可以从外部改变类名，let同时也避免了class的变量提升，通过<code>new.target</code>来验证函数的调用是否应该使用<code>new</code>，通过<code>Object.defineProperty</code>来设置方法不可枚举。</p>
<h4>类表达式</h4>

<p>类有两种定义方式：类声明和类表达式，类似于函数声明和函数表达式，类声明的主要目的是为了将类作为一等公民传递到函数中。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;ES5中的类结构实现:&lt;/h4&gt;

&lt;p&gt;ES5中类似于类的实现是先创造一个构造函数，然后在其原型上定义方法，例如：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;d
    
    </summary>
    
    
      <category term="ES6" scheme="https://stevens1995.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>CSS揭秘</title>
    <link href="https://stevens1995.github.io/2017/09/14/CSS%E6%8F%AD%E7%A7%98/"/>
    <id>https://stevens1995.github.io/2017/09/14/CSS揭秘/</id>
    <published>2017-09-14T10:23:22.000Z</published>
    <updated>2017-09-15T01:03:22.588Z</updated>
    
    <content type="html"><![CDATA[<h4>1.半透明边框</h4>

<p>关键点：为元素设置背景颜色后，颜色会延伸至border的下面，所以当border为透明时看到的就是背景颜色<br>解决方法：border-clip:padding-box;</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;1.半透明边框&lt;/h4&gt;

&lt;p&gt;关键点：为元素设置背景颜色后，颜色会延伸至border的下面，所以当border为透明时看到的就是背景颜色&lt;br&gt;解决方法：border-clip:padding-box;&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ES6中的Symbol类型</title>
    <link href="https://stevens1995.github.io/2017/09/08/ES6%E4%B8%AD%E7%9A%84Symbol%E7%B1%BB%E5%9E%8B/"/>
    <id>https://stevens1995.github.io/2017/09/08/ES6中的Symbol类型/</id>
    <published>2017-09-08T01:14:00.000Z</published>
    <updated>2017-09-28T14:24:59.822Z</updated>
    
    <content type="html"><![CDATA[<h4>Symbols and Symbol properties</h4>

<p>Symbol 是继javaScript的 string、number、boolean、undefined、null之后的第六个基本类型，创建Symbol的初衷是为了建立对象的私有属性。</p>
<a id="more"></a>
<p>创建Symbol：</p>
<p>Symbol没有字面量形式，通过Symbol来创建一个新的Symbol，可以在函数中添加描述信息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">let</span> firstname = <span class="built_in">Symbol</span>(<span class="string">'firstname'</span>);</div><div class="line"><span class="keyword">let</span> person = &#123;&#125;;</div><div class="line"></div><div class="line">person[firstname] = <span class="string">"Stevens"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person[firstname]);</div></pre></td></tr></table></figure>
<p>共享Symbol:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> fir = <span class="built_in">Symbol</span>.for(<span class="string">'global'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> sec = <span class="built_in">Symbol</span>.for(<span class="string">'global'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(fir == sec);</div></pre></td></tr></table></figure>
<p>可以用Symbol.keyFor取回全局Symbol的关键字</p>
<p>关于Symbol的强制转换，Symbol不能转换为string或者number类型，所以下面的两行代码会报错：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> fir = <span class="built_in">Symbol</span>(<span class="string">'fir'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(fir+<span class="string">' '</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(fir/<span class="number">1</span>);</div></pre></td></tr></table></figure>
<p>读取对象的Symbol属性：</p>
<p>Object.keys和Object.getOwnPropertyNames()都不能获得Symbol属性，可通过Object.getOwnPropertySymbols()获取对象所有的Symbols属性</p>
<p>ES6对象中有关Symbol的操作和方法：</p>
<hr>
<p>Symbol.hasInstance - A method used by instanceof to determine an object’s inheritance.</p>
<p>Symbol.isConcatSpreadable - A Boolean value indicating that Array.prototype.concat() should flatten the collection’s elements if the collection is passed as a parameter to Array.prototype.concat().</p>
<p>Symbol.iterator - A method that returns an iterator.</p>
<p>Symbol.match - A method used by String.prototype.match() to compare strings.</p>
<p>Symbol.replace - A method used by String.prototype.replace() to replace substrings.</p>
<p>Symbol.search - A method used by String.prototype.search() to locate substrings.</p>
<p>Symbol.species - The constructor for making derived objects. </p>
<p>Symbol.split - A method used by String.prototype.split() to split up strings.</p>
<p>Symbol.toPrimitive - A method that returns a primitive valuerepresentation of an object.</p>
<p>Symbol.toStringTag - A string used by Object.prototype.toString() to create an object description.</p>
<p>Symbol.unscopables - An object whose properties are the names of object properties that should not be included in a with statement.</p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;Symbols and Symbol properties&lt;/h4&gt;

&lt;p&gt;Symbol 是继javaScript的 string、number、boolean、undefined、null之后的第六个基本类型，创建Symbol的初衷是为了建立对象的私有属性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ES6" scheme="https://stevens1995.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>Vue生命周期</title>
    <link href="https://stevens1995.github.io/2017/09/07/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://stevens1995.github.io/2017/09/07/Vue生命周期/</id>
    <published>2017-09-07T07:48:28.000Z</published>
    <updated>2017-09-07T08:57:34.020Z</updated>
    
    <content type="html"><![CDATA[<h4>Vue.js生命周期</h4>

<h4>Creation</h4>

<p>beforeCreate: 在Observe data和init Events之前，数据还不是响应式的，事件不存在。</p>
<p>created：在Observe data和init Events之后</p>
<h4>Mounting</h4>

<p>beforeMount: 在 template 和 render Function 被编译之前</p>
<p>mounted: 模板和渲染函数已经被编译，可以访问。</p>
<a id="more"></a>
<h4>Updating</h4>

<p>beforeUpdate: 数据已经被修改但是还没有被重新渲染</p>
<p>updated: template 和 DOM中的数据已经被修改后</p>
<h4>Destruction</h4>

<p>beforeDestory: Vue实例被销毁之前</p>
<p>destoryed: 实例已经被销毁，做一些最后的工作，比如向服务端发送消息。</p>
<p><img src="https://raw.githubusercontent.com/Stevens1995/blogImages/master/20170907/component-lifecycle.png" alt="Lifecycle" width="600" height="1300"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;Vue.js生命周期&lt;/h4&gt;

&lt;h4&gt;Creation&lt;/h4&gt;

&lt;p&gt;beforeCreate: 在Observe data和init Events之前，数据还不是响应式的，事件不存在。&lt;/p&gt;
&lt;p&gt;created：在Observe data和init Events之后&lt;/p&gt;
&lt;h4&gt;Mounting&lt;/h4&gt;

&lt;p&gt;beforeMount: 在 template 和 render Function 被编译之前&lt;/p&gt;
&lt;p&gt;mounted: 模板和渲染函数已经被编译，可以访问。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Vue.js" scheme="https://stevens1995.github.io/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>DOM相关(待总结和扩展)</title>
    <link href="https://stevens1995.github.io/2017/09/07/DOM%E7%9B%B8%E5%85%B3(%E5%BE%85%E6%80%BB%E7%BB%93%E5%92%8C%E6%89%A9%E5%B1%95)/"/>
    <id>https://stevens1995.github.io/2017/09/07/DOM相关(待总结和扩展)/</id>
    <published>2017-09-07T04:52:50.000Z</published>
    <updated>2017-09-08T08:45:43.807Z</updated>
    
    <content type="html"><![CDATA[<h4>Document Object Model</h4>

<p>DOM(document object model)是针对HTML和XML的一个API。DOM描述了一个层次化的节点树，允许开发人员添加、修改和删除节点。</p>
<p>Node类型：</p>
<p>DOM1级定义的Node类型接口，DOM中所有的节点都有实现这个接口。  </p>
<p>nodeType、nodeName、nodeValue</p>
<p>childNodes对象、parentNode、previousSibling、nextSibling</p>
<p>appendChild()、insertBefore()、replaceChild()、removeChild()</p>
<p>cloneNode()、normalize()</p>
<p>Document类型:</p>
<p>Document类型表示文档。浏览器中，document是HTMLDocument(继承自Document类型)的一个实例。</p>
<p>nodeType:9<br>nodeName:”#document”</p>
<p>document.documentElement表示第一个节点(html) 等于document.childNodes[0];</p>
<p>因为经常使用，document.body指向body节点</p>
<p>doctype:一般使用document.doctype取得对文档类型声明的引用  </p>
<p>不同浏览器有差异，有的将文档类型声明作为节点，可通过childNodes访问，有的不行，etc</p>
<p>document是HTMLDocument类型的一个实例，有一些Document类型没有的属性:</p>
<p>document.title、document.URL、document.domain、document.referrer</p>
<p>DOM一致性检测：</p>
<p>document.implementation()</p>
<p>文档写入：</p>
<p>document.write()、document.writeln、document.open()、document.close()</p>
<p>Element类型：</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;Document Object Model&lt;/h4&gt;

&lt;p&gt;DOM(document object model)是针对HTML和XML的一个API。DOM描述了一个层次化的节点树，允许开发人员添加、修改和删除节点。&lt;/p&gt;
&lt;p&gt;Node类型：&lt;/p&gt;
&lt;p&gt;DOM1级
    
    </summary>
    
    
      <category term="javascript" scheme="https://stevens1995.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>XSS和CSRF初步了解</title>
    <link href="https://stevens1995.github.io/2017/09/06/XSS%E5%92%8CCSRF%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3/"/>
    <id>https://stevens1995.github.io/2017/09/06/XSS和CSRF初步了解/</id>
    <published>2017-09-06T01:31:53.000Z</published>
    <updated>2017-09-06T02:35:34.728Z</updated>
    
    <content type="html"><![CDATA[<h4>XSS &amp; CSRF</h4>

<p>XSS:cross-site-scripting 跨站点脚本<br>CSRF:cross-site-request-forgery 跨站点请求伪造</p>
<p>XSS：攻击者不直接锁定要攻击的目标，通过向某些存在漏洞的网站（比如将用户输入不经过验证直接输出到网站）注入脚本，等到用户访问网站时，脚本运行从而达到攻击的目的。</p>
<p>存储型XSS:<br><img src="https://raw.githubusercontent.com/Stevens1995/blogImages/master/20170906/sorted-XSS.png" alt="XSS"></p>
<a id="more"></a>
<p>XSS的类型：</p>
<p>存储型（stored XSS）：又叫做持续型，注入的数据（被攻击者接收的数据）会存储在服务端，比如服务器。<br>反射型（reflected XSS）：用户的输入立即返回<br>基于DOM的XSS（DOM based XSS）：数据来源和数据接收的地方都是DOM，数据流不会离开客户端</p>
<p>防止XSS攻击：验证来自于客户端的数据或进行相关的处理</p>
<p>CSRF：攻击者通过已经通过验证，服务端完全信任的客户端（被攻击者）来发送http请求，从而达到攻击的目的</p>
<p><img src="https://raw.githubusercontent.com/Stevens1995/blogImages/master/20170906/csrf.png" alt="CSRF"></p>
<p>e.g. 攻击者向被攻击者发送一个图片 <code>&lt;img src=&quot;/attack?transferfund=4000&quot; alt=&quot;&quot;&gt;</code> 诱导被攻击者点击后，发送给服务器，服务器以为是经过认证的被攻击者发送的正常的请求，所以请求相映成功。</p>
<p>防止CSRF： 1.每次打开一个会话服务端向客户端发送一个唯一的不可预测的随机的数，每个正常的http请求都会隐蔽的带着这个随机数，从而让服务端能够判断是否是CSRF攻击请求<br>2.强制用户重新认证</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;XSS &amp;amp; CSRF&lt;/h4&gt;

&lt;p&gt;XSS:cross-site-scripting 跨站点脚本&lt;br&gt;CSRF:cross-site-request-forgery 跨站点请求伪造&lt;/p&gt;
&lt;p&gt;XSS：攻击者不直接锁定要攻击的目标，通过向某些存在漏洞的网站（比如将用户输入不经过验证直接输出到网站）注入脚本，等到用户访问网站时，脚本运行从而达到攻击的目的。&lt;/p&gt;
&lt;p&gt;存储型XSS:&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Stevens1995/blogImages/master/20170906/sorted-XSS.png&quot; alt=&quot;XSS&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="security" scheme="https://stevens1995.github.io/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>javascript事件模型</title>
    <link href="https://stevens1995.github.io/2017/09/05/javascript%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/"/>
    <id>https://stevens1995.github.io/2017/09/05/javascript事件模型/</id>
    <published>2017-09-05T01:01:11.000Z</published>
    <updated>2017-09-05T01:40:04.126Z</updated>
    
    <content type="html"><![CDATA[<h4>javascript事件模型</h4>


<h4>事件流：</h4>

<p>IE事件流：事件冒泡：事件最开始由具体的的元素接收，然后向上传播至不具体的节点。</p>
<p>Netscape: 事件捕获：不具体的的节点先接收到事件，具体的节点后接收到事件。</p>
<p>DOM事件流：事件捕获阶段、处于目标阶段、事件冒泡阶段。</p>
<a id="more"></a>
<h4>事件处理程序：</h4>

<p>HTML事件处理程序：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">onclick</span>=<span class="string">"alert('clicked.')"</span>&gt;</span></div></pre></td></tr></table></figure>
<p>this的值等于目标元素</p>
<p>DOM0级事件处理程序：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'mybtn'</span>);</div><div class="line"></div><div class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	alert(<span class="keyword">this</span>.id);</div><div class="line">&#125;</div><div class="line"></div><div class="line">btn.onclick = <span class="literal">null</span>;<span class="comment">//删除事件处理程序</span></div></pre></td></tr></table></figure>
<p>this指向目标元素</p>
<p>DOM2级事件处理程序：</p>
<p><code>addEventListener &amp; removeEventListener</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'mybtn'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	alert(<span class="keyword">this</span>.id);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">btn.addEventListener(<span class="string">'click'</span>,handle,<span class="literal">false</span>);<span class="comment">//true表示在事件捕获阶段处理程序，fasle表示在事件冒泡阶段处理程序</span></div><div class="line"></div><div class="line">btn.addEventListener(<span class="string">'click'</span>,handle,<span class="literal">true</span>);<span class="comment">//可以在事件捕获阶段再定义处理程序，与冒泡阶段互不影响，移除的时候也要分别移除</span></div><div class="line"></div><div class="line"></div><div class="line">btn.addEventListener(<span class="string">'click'</span>,handle2,<span class="literal">false</span>);</div><div class="line"></div><div class="line"><span class="comment">//可以添加多个事件处理程序，按照定义的顺序执行</span></div><div class="line"></div><div class="line"></div><div class="line">btn.removeEventListener(<span class="string">'click'</span>,handle,<span class="literal">false</span>);</div></pre></td></tr></table></figure>
<p>IE事件处理程序：</p>
<p><code>attachEvent &amp; detachEvent</code></p>
<p>通过attach添加的时间处理程序只会在冒泡阶段发生。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'mybtn'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</div><div class="line">&#125;</div><div class="line"></div><div class="line">btn.attachEvent(<span class="string">'onclick'</span>,handle);<span class="comment">//与DOM2不同的是这里添加的是时间处理程序的名称不是事件名称</span></div><div class="line"></div><div class="line">btn.detachEvent(<span class="string">'onclick'</span>,handle);</div></pre></td></tr></table></figure>
<h4>跨浏览器处理程序：</h4>

<p>检测对应的对象是否存在然后决定使用哪个，注意检测顺序：DOM2 -&gt; IE -&gt;HTML事件处理程序</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;javascript事件模型&lt;/h4&gt;


&lt;h4&gt;事件流：&lt;/h4&gt;

&lt;p&gt;IE事件流：事件冒泡：事件最开始由具体的的元素接收，然后向上传播至不具体的节点。&lt;/p&gt;
&lt;p&gt;Netscape: 事件捕获：不具体的的节点先接收到事件，具体的节点后接收到事件。&lt;/p&gt;
&lt;p&gt;DOM事件流：事件捕获阶段、处于目标阶段、事件冒泡阶段。&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript事件模型" scheme="https://stevens1995.github.io/tags/javascript%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>TCP三次握手四次挥手</title>
    <link href="https://stevens1995.github.io/2017/09/04/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>https://stevens1995.github.io/2017/09/04/TCP三次握手四次挥手/</id>
    <published>2017-09-04T06:32:25.000Z</published>
    <updated>2017-09-08T04:35:24.827Z</updated>
    
    <content type="html"><![CDATA[<h4>TCP三次握手四次挥手</h4>


<h4>three handshake:</h4>


<p><img src="https://raw.githubusercontent.com/Stevens1995/blogImages/master/20170904/handshake.png" alt="tcp_handshake"></p>
<a id="more"></a>
<p>1.首先客户端的TCP首先向服务端发送一个特殊的TCP报文段，报文段首部的SYN标志位被置为1，另外，客户端会随机地选择一个初始序号(seq)，并将此编号放置于该报文段的序号字段中，随后报文被封装到一个IP数据报中并发送给服务器</p>
<p>2.服务器提取出TCP报文段,为该TCP连接分配TCP缓存和变量，并想该客户端TCP发送允许连接的报文段。报文段的SYN标志位置为1，首部确认号字段被置为seq+1，最后服务端选择自己的初始序列号seq。</p>
<p>3.客户端TCP收到服务端允许连接的报文段后，客户端也要为该连接分配缓存和变量。客户端再向服务器发送确认报文段，序号seq为之前的序号加一，确认字段ACK为seq_server加一，最后一部SYN置为0，连接建立。</p>
<h4>four waved:</h4>



<p><img src="https://raw.githubusercontent.com/Stevens1995/blogImages/master/20170904/waved.png" alt=""></p>
<p>一个TCP连接中的双方都能终止连接，比如客户端要终止连接，客户端即发送TCP报文段，FIN标志位置为1，服务端收到后发送一个确认报文段，客户端联机即终止。服务端要终止的话也要进行相同的操作。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;TCP三次握手四次挥手&lt;/h4&gt;


&lt;h4&gt;three handshake:&lt;/h4&gt;


&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Stevens1995/blogImages/master/20170904/handshake.png&quot; alt=&quot;tcp_handshake&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>事件委托</title>
    <link href="https://stevens1995.github.io/2017/09/04/%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/"/>
    <id>https://stevens1995.github.io/2017/09/04/事件委托/</id>
    <published>2017-09-04T03:22:56.000Z</published>
    <updated>2017-09-06T11:34:33.278Z</updated>
    
    <content type="html"><![CDATA[<h4>javascript delegation(事件委托)</h4>

<p>事件委托能够避免在js中为很多具体的节点添加事件监听，只需为父元素添加即可。通过父元素的事件监听来分析事件冒泡从而获得匹配的子元素。</p>
<a id="more"></a>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"parent-list"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"post-1"</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"post-2"</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"post-3"</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"post-4"</span>&gt;</span>Item 4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"post-5"</span>&gt;</span>Item 5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"post-6"</span>&gt;</span>Item 6<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// Get the element, add a click listener...</span></div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">"parent-list"</span>).addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">	<span class="comment">// e.target is the clicked element!</span></div><div class="line">	<span class="comment">// If it was a list item</span></div><div class="line">	<span class="keyword">if</span>(e.target &amp;&amp; e.target.nodeName == <span class="string">"LI"</span>) &#123;</div><div class="line">		<span class="comment">// List item found!  Output the ID!</span></div><div class="line">		<span class="built_in">console</span>.log(<span class="string">"List item "</span>, e.target.id.replace(<span class="string">"post-"</span>, <span class="string">""</span>), <span class="string">" was clicked!"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;javascript delegation(事件委托)&lt;/h4&gt;

&lt;p&gt;事件委托能够避免在js中为很多具体的节点添加事件监听，只需为父元素添加即可。通过父元素的事件监听来分析事件冒泡从而获得匹配的子元素。&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="https://stevens1995.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Grid详解</title>
    <link href="https://stevens1995.github.io/2017/08/31/Grid%E8%AF%A6%E8%A7%A3/"/>
    <id>https://stevens1995.github.io/2017/08/31/Grid详解/</id>
    <published>2017-08-31T10:02:20.000Z</published>
    <updated>2017-09-19T02:20:51.556Z</updated>
    
    <content type="html"><![CDATA[<h4>Grid详解</h4>

<h4>容器属性:</h4>

<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#container</span>&#123;</div><div class="line">	<span class="attribute">display</span>: grid | inline-grid | subgrid; <span class="comment">/* 定义一个grid容器*/</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#container</span>&#123;</div><div class="line">	<span class="attribute">grid-template-columns</span>:;   <span class="comment">/*定义容器的列*/</span></div><div class="line">	<span class="attribute">grid-template-rows</span>:;  <span class="comment">/*定义容器的行*/</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#container</span>&#123;</div><div class="line">	<span class="attribute">grid-template-areas</span>: ; </div><div class="line">	<span class="comment">/*划分容器的区域,分别为每个单元分配单元属于哪个部分,指定之后便可以在子项目中用grid-area来占用这个区域*/</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#container</span>&#123;</div><div class="line">	<span class="attribute">grid-column-gap</span>:; </div><div class="line">	<span class="attribute">grid-row-gap</span>:;</div><div class="line">	<span class="comment">/*定义track间线的宽度*/</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#container</span>&#123;</div><div class="line">	<span class="attribute">justify-content</span>: ; <span class="comment">/*定义容器的剩余空间如何排列*/</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;Grid详解&lt;/h4&gt;

&lt;h4&gt;容器属性:&lt;/h4&gt;

&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;
    
    </summary>
    
    
      <category term="css" scheme="https://stevens1995.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Flex详解</title>
    <link href="https://stevens1995.github.io/2017/08/30/Flex%E8%AF%A6%E8%A7%A3/"/>
    <id>https://stevens1995.github.io/2017/08/30/Flex详解/</id>
    <published>2017-08-30T06:26:22.000Z</published>
    <updated>2017-09-19T02:05:22.226Z</updated>
    
    <content type="html"><![CDATA[<h4>Flex详解</h4>

<h4>总览:</h4>

<p><img src="https://raw.githubusercontent.com/Stevens1995/blogImages/master/20170830/flexbox.png" alt="flex总览"></p>
<a id="more"></a>
<h4>Flex container属性:</h4>

<p><code>display:flex:</code>定义一个Flex容器</p>
<p><code>flex-direction:</code> 建立主轴，定义项目在主轴上的排列方向 </p>
<p>row | row-reverse | column | column-reverse<br>row(默认):主轴水平方向，项目从左到右排列<br>row-reverse:主轴水平，项目从右到左<br>column:主轴垂直，项目从上到下<br>column-reverse:主轴垂直，项目从下到上</p>
<p><code>flex-wrap:</code>默认的所有项目在主轴上排列，不换行，可通过flex-wrap来改变  </p>
<p><code>nowrap | wrap | wrap-reverse</code></p>
<p>nowrap(默认):所有项目排列在主轴上不换行<br>wrap:换行，项目从顶部到底部<br>wrap-reverse:不换行，项目从底部到顶部</p>
<p><code>flex-flow:</code> flex-direction 和 flex-wrap的简写</p>
<p>flex-flow: &lt;’flex-direction’&gt; || &lt;’felx-wrap’&gt;</p>
<p><code>justify-content:</code>定义项目在主轴上的排列</p>
<p><code>flex-start | flex-end | center | space-between | space-around | space-evenly</code></p>
<p>flex-start(默认):项目从主轴开始的地方开始排列<br>flex-end:从主轴结束的地方开始排列<br>center:项目排列在主轴中间<br>space-between:项目均匀分布在主轴上，第一个在开始线，最后一个在结束线，中间的项目均匀分布<br>space-around:每个项目左边和右边的空隙一样(注意，中间的间隔是左右间隔的两倍)<br>space-evenly:项目间的间隔一样(所有间隔都一样)</p>
<p><code>align-items:</code>项目在交叉轴上的布局</p>
<p><code>flex-start | flex-end | center | stretch | baseline</code></p>
<p>flex-start:项目在交叉轴的边缘从交叉轴的开始处开始<br>flex-end:项目在交叉轴的边缘从交叉轴的结束处开始<br>center:f项目处在交叉轴中间<br>baseline:项目根据基线对齐<br>stretch:伸展填充container  </p>
<p><code>align-content:</code>排列 主轴上的行 在交叉轴上的空间 (当主轴只有一行时这个属性不起作用)</p>
<p><code>flex-start | flex-end | center | space-between | space-around | stretch</code></p>
<p>flex-start:行从交叉轴开始的地方排列<br>flex-end:行从交叉轴结束的地方开始排列<br>center:行在交叉轴的中间<br>space-between:行之间的间隔相等，第一行在交叉轴开始线处，最后一行在交叉轴结束线处<br>space-around:每行左右间距相同<br>stretch:行伸展以填充container</p>
<h4>Flex items属性:</h4>

<p><code>order:</code>定义项目排列的顺序</p>
<p>order:<integer></integer></p>
<p><code>flex-grow:</code>:定义项目扩大的能力，接收一个没有单位的值代表比例，决定占据多少主轴上剩余的可用空间  </p>
<p><code>flex-shrink:</code>定义项目缩小的能力(负值无效)  </p>
<p><code>flex-basis:</code>定义在分配剩余空间之前项目的默认大小</p>
<p><code>flex:</code>前面三个属性的简写</p>
<p>flex: flex-grow || flex-shrink || flex-basis</p>
<p><code>align-self:</code>定义个别项目在交叉轴上排列方式，这可以覆盖在container上定义的align-item属性</p>
<p><code>flex-start | flex-end</code></p>
<p>flex-start:从交叉轴的开始线处开始排列<br>flex-end:从交叉轴的结束线处开始排列</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;Flex详解&lt;/h4&gt;

&lt;h4&gt;总览:&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Stevens1995/blogImages/master/20170830/flexbox.png&quot; alt=&quot;flex总览&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="CSS" scheme="https://stevens1995.github.io/tags/CSS/"/>
    
  </entry>
  
</feed>

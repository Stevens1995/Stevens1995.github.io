<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Truly reactive programming with Svelte3.0 | 动力小车</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Truly reactive programming with Svelte3.0</h1><a id="logo" href="/.">动力小车</a><p class="description">My soul My feel My life</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Truly reactive programming with Svelte3.0</h1><div class="post-meta">2019-05-30<span> | </span><span class="category"><a href="/categories/%E7%BF%BB%E8%AF%91/">翻译</a></span></div><div class="post-content"><blockquote>
<p>本文是一篇翻译过来的文章，原文地址：<a href="https://blog.logrocket.com/truly-reactive-programming-with-svelte-3-0-321b49b75969" target="_blank" rel="noopener">https://blog.logrocket.com/truly-reactive-programming-with-svelte-3-0-321b49b75969</a></p>
</blockquote>
<p><img src="https://cdn-images-1.medium.com/max/1200/1*2hDcp8VSEJk74trofc3JtQ.jpeg" alt="Svelte"></p>
<p>这个标题有点戏剧性，但是话又说回来，Svelte背后的想法正是如此。如果你还不知道Svelte是什么，那赶紧过来瞅瞅 — 你将会看到一场革命，并且Svelte将会取得最后的胜利（并不是在对Svelte团队施加压力哈:sweat_smile:）。</p>
<a id="more"></a>

<p>请注意本文并不是学习和使用Svelte的教程。Svelte团队已经提供了一份很棒的<a href="https://svelte.dev/tutorial/basics" target="_blank" rel="noopener">一步一步的互动式</a>教程，以便帮助你走进反应式编程的世界。</p>
<p><strong>免责声明</strong>：我不是编程界的摇滚明星，我不可能知道所有事情。我只是对每天发生的新鲜事情感到好奇，并且在我可以的时候分享- 于是就有了这篇文章。请带着一些怀疑的想法来看待这里我所说的事情，并且，如果我说了一些愚蠢的话，麻烦及时让我知道。</p>
<p>好嘞！让我们开始吧！:boom:</p>
<h2 id="首先，关于React"><a href="#首先，关于React" class="headerlink" title="首先，关于React"></a>首先，关于React</h2><p>在我开始讨论为什么Svelte如此强大之前，我们先来看看Dan的一条推文，一段时间后我们再来看看其中表达的意思：</p>
<blockquote class="twitter-tweet" data-lang="zh-cn"><p lang="en" dir="ltr">React is not fully reactive</p>&mdash; Dan Abramov (@dan_abramov) <a href="https://twitter.com/dan_abramov/status/1025801430668664833?ref_src=twsrc%5Etfw" target="_blank" rel="noopener">2018年8月4日</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<p><strong>另一份免责声明</strong>：这篇文章也不是以任何方式批评和攻击React。我只是简单地决定用React作为一个学习案例，因为此文的大部分读者应该都用过一点React。React是跟Svelte对比的一个很好地案例。</p>
<p>Dan到底想表达什么，这对我们现在的编程方式有何影响呢？在回答这个问题前，让我简单地向你介绍下React背后的工作原理。</p>
<p>当你渲染一个React应用时，React保存了一份DOM的拷贝，称作<a href="https://reactjs.org/docs/faq-internals.html" target="_blank" rel="noopener">虚拟DOM</a>。虚拟DOM充当你的React代码和浏览器渲染DOM之间的中间人。</p>
<p>每当你的数据改变时（比如当你调用<code>this.setState</code>，<code>useState</code>），React做了一点工作来决定如何重绘屏幕上的UI。数据更新后，React会对比虚拟DOM和真实DOM，并且只更新两者间不同的地方。这样就避免了每次数据改变时都要重新渲染整个DOM。</p>
<p>现在，一切都变得很迅速，因为更新虚拟DOM比更新真实DOM所耗费的性能小很多，React只更新了真实DOM确实需要更新的部分。<a href="https://medium.com/@gethylgeorge/how-virtual-dom-and-diffing-works-in-react-6fc805f9f84e" target="_blank" rel="noopener">这篇</a>文章很好地讲述了整个过程。</p>
<p>但是！但是啊，聪明的你可能已经注意到了一些事情。那就是，如果你不告诉React你的数据发生了改变（比如，通过调用<code>this.setState</code>或者钩子函数），你的虚拟DOM就不会发生改变，React就不再react了。（ba dum tss! 🤓）（这句翻译不来…有点像 dumb ass…）</p>
<p>这就是Dan为什么说React不是完全reactive的原因。React依赖用户来跟踪应用中的数据，通过用来告诉自己数据发生了改变，但这对用户来说通常是额外的工作。</p>
<h2 id="OK，让我们来看看Svelte"><a href="#OK，让我们来看看Svelte" class="headerlink" title="OK，让我们来看看Svelte"></a>OK，让我们来看看Svelte</h2><p>Svelte提供一种全新的方式来搭建超级快速，高效，真正响应式行为的UI。没有虚拟DOM，并且代码行数比所有其他你用过框架或者包更少。</p>
<p>这听起来很棒，但是它与众多的JavaScript框架有什么不同呢？Let me show you :smirk:</p>
<h3 id="真正的反应式"><a href="#真正的反应式" class="headerlink" title="真正的反应式"></a>真正的反应式</h3><p>Svelte不是一个包或者框架。Svelte是一个编译器，它接受原生的JavaScript代码，输出的Javascript也是直接与DOM交互，而不需要任何其他东西充当中介。</p>
<p>等一下？什么？一个编译器？（作者戏真多…）。 是的—– 一个编译器。这是一个非常棒的想法，我不明白为什么直到现在Svelte还不是很惹人注意，现在，让我来告诉你为什么Svelte是那么地酷炫。</p>
<p>以下是<a href="https://www.youtube.com/watch?v=AdNJ3fydeao" target="_blank" rel="noopener">Rich Harris在YGLF 2019年会议上的讲话</a>：</p>
<blockquote>
<p>Svelte 3.0将反应性从组件API移入语言中。<br>(Svelte 3.0 moves reactivity out of the component API and into the language.)</p>
</blockquote>
<p>这句话是什么意思呢？我们已经知道了React（以及很多其他的前端框架）需要你调用特定的API来告诉其数据发生了改变（通过调用<code>this.setState</code>或者<code>useState</code>）才能更新它的虚拟DOM。在React中，需要调用<code>this.setState</code>意味着你的应用的反应性其实是绑定在特定的API上，没有这些API，数据的改变并不会被注意到。</p>
<p>而Svelte通过另一种方式来实现反应性。</p>
<p>Svelte从<a href="">Observable</a>运行代码的方式中获取到了灵感，以拓扑代替从上至下的方式来运行代码。我们通过下面这段代码来看看什么是通过拓扑顺序来执行代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> square =&gt; <span class="function"><span class="params">number</span> =&gt;</span> number * number;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">const</span> secondNumber = square(firstNumber);</span><br><span class="line">   <span class="keyword">const</span> firstNumber = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log(secondNumber);</span><br><span class="line">   &#125;)();</span><br></pre></td></tr></table></figure>

<p>如果你从上至下运行这段代码的话，解释到在第4行的时候，程序会报错。因为<code>secondNunmber</code>依赖于<code>firstNumber</code>，但<code>firstNumber</code>还没有被定义。但是如果程序以拓扑的方式来执行的话，程序不会报任何错误。为什么呢？以为编译器不会自上而下执行代码，而是会查看所有的变量从而生成一个依赖图（即谁被需要谁先被执行）</p>
<p>在上述的例子中，要理解编译器如果以拓扑的方式编译代码很简单：</p>
<ol>
<li><code>square</code>变量依赖其他变量吗？</li>
</ol>
<p>-没有，初始化<code>square</code><br>2. <code>secondNumber</code>依赖于其他变量吗？<br>-<code>secondNumber</code>依赖于<code>square</code>和<code>firstNumber</code>,<code>square</code>已经被初始化，但是<code>firstNumber</code>还没有被初始化，初始化<code>firstNumber</code><br>3. OK，<code>firstNumber</code>已经被初始化，现在可以用<code>firstNumber</code>和<code>square</code>来初始化<code>secondNumber</code><br>-还有其他的变量需要初始化吗？没有-执行代码</p>
<p>乍一看，这段代码似乎依然是从上到下执行的，但是仔细看的话，你会发现实际上代码执行时会有一些跳转。</p>
<p>当代码执行到第四行时，编译器发现<code>firstNumber</code>并没有被定义，于是编译器暂停解释该语句，并且在你的代码中寻找该变量的定义。当找到<code>firstNumber</code>在第五行被定义后，第五行会先于第四行执行，当第五行执行完毕后，再返回执行第四行。</p>
<p><em><strong>TL;DR：如果语句A依赖于语句B，不管语句声明的顺序如何，B将先于A执行</strong></em></p>
<p>Svelte是如何应用上述的原理以实现真正的反应式呢？在Svelte中，你可以用一个标识符来表示一个语句，像这样：<code>$: foo = bar</code>。这样做之后，语句<code>foo = bar</code>就有了一个表示<code>$</code>（上述语句在严格模式下会报错）</p>
<p>当Svelte看到任何有<code>$</code>前缀的语句时，编译器就知道左边的变量由右边的变量导出。于是，现在我们有了将一个变量绑定在另一个变量的方法。</p>
<p>Reactivity!(反应式!)这意味着现在我们用JavaScript的原生API来实现真正的响应式，而无需再摆弄一些三方API，比如<code>this.setState</code>。</p>
<p>下面的代码是这样写的实际效果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vanilla js</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> bar = foo + <span class="number">10</span>; <span class="comment">// bar is now 20</span></span><br><span class="line">foo = bar <span class="comment">// bar is still 20 (no reactivity)</span></span><br><span class="line">bar = foo + <span class="number">5</span> <span class="comment">// now bar becomes 25</span></span><br><span class="line"><span class="comment">// svelte js</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="number">10</span>;</span><br><span class="line">$: bar = foo + <span class="number">10</span>; <span class="comment">// bar is now 20</span></span><br><span class="line">foo = <span class="number">15</span> <span class="comment">// bar is now 25 because it is bound to the value of foo</span></span><br></pre></td></tr></table></figure>

<p>在上述的Svelte代码中，我们并不需要将<code>foo</code>的新值重新赋值给<code>bar</code>，代码会帮我们自动处理。当你把<code>foo</code>的值更改为15时，<code>bar</code>会自动更新为25。</p>
<p>上述的Svelte代码经过编译后，大概便变成这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">... omitted <span class="keyword">for</span> brevity ...</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instance</span>(<span class="params">$$self, $$props, $$invalidate</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> foo = <span class="number">10</span>; <span class="comment">// bar is now 20</span></span><br><span class="line">   $$invalidate(<span class="string">'foo'</span>, foo = <span class="number">15</span>) <span class="comment">// bar is now 25 because it is bound to the value of foo</span></span><br><span class="line">   <span class="keyword">let</span> bar;</span><br><span class="line">   $$self.$$.update = <span class="function">(<span class="params">$$dirty = &#123; foo: <span class="number">1</span> &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> ($$dirty.foo) &#123; $$invalidate(<span class="string">'bar'</span>, bar = foo + <span class="number">19</span>); &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="keyword">return</span> &#123; bar &#125;;</span><br><span class="line"> &#125;</span><br><span class="line">... omitted <span class="keyword">for</span> brevity ...</span><br></pre></td></tr></table></figure>
<p><strong>花点时间认真看看上面的代码，真的，认真看下。</strong></p>
<p>你看到<code>foo</code>是如何更新的吗？即使是在<code>bar</code>没有被定义之前。（我暂时没看懂…）这是因为Svelte的编译器以拓扑的顺序来执行代码，而不是自上而下。</p>
<p>Svelte自动对数据的更新做出改变，而不需要用户关系改变的内容和时间，这一切都是自动进行的。用户可以专注于代码逻辑，让Svelte根据应用状态的改变来调节UI。</p>
<h3 id="简洁"><a href="#简洁" class="headerlink" title="简洁"></a>简洁</h3><p>记得我说过Svelte可以用更少的代码来做到相同的工作吗？我是认真的！看看下面这个组件分别用Svelte和React实现的版本：</p>
<p><img src="https://i1.wp.com/cdn-images-1.medium.com/max/1600/1*y8KNWov5UwulVryUPq6srw@2x.png?ssl=1" alt="Svelte &amp; React"></p>
<p><strong><strong>17行代码 vs 29行代码</strong></strong></p>
<p>上述两个应用实现的功能几乎完全一样，但是你可以看到在<code>React.js</code>中，我们不得不编写更多地代码 —- <code>Angular</code>里面更过分。</p>
<p><img src="https://i2.wp.com/cdn-images-1.medium.com/max/1600/1*129rCsjvqwpczQ5Ld_U44A@2x.png?ssl=1" alt="Svelte &amp; React"></p>
<p>Svelte简洁的代码除了看起来更方便之外，同时也更利于逻辑的判断和推理，因为代码中没有其他冗余的部分。我们不需要事件处理程序来更新input输入–简单的绑定就可以了。</p>
<p>假如你是一个刚刚入门的web开发者，哪一种方式学习起来更加简单？左边？还是右边？</p>
<p>或许你认为仅仅是少一点代码看起来很微不足道，但是当你所负责的项目变得越来越大，越来越复杂时，简洁的代码就变得很重要。我个人发现，有时候需要花费数个小时才能理解一个同事写的<code>React</code>组件。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>OK，我们已经见识到了Svelte如何实现真正的反应式，并且让我们的代码更加简短和简洁。那么性能呢？如果用Svelte来编写完整的应用，用户体验如何？</p>
<p>一个让<code>React</code>如此强大的原因是<code>React</code>使用虚拟DOM来更新UI中很少的一部分，避免了每次数据改变时都重绘整个DOM。但是，这种方法有一个缺点是，当一个<code>React</code>组件改变时，<code>React</code>会重新渲染所有的子组件，不管子组件是否有重新渲染的必要。这就是为什么<code>React</code>提供了<code>shouldComponentUpdate</code>，<code>useMemo</code>，<code>React.PureComponent</code>等API。只要使用虚拟DOM来更新UI，这个问题就会一直存在。</p>
<p>Svelte没有使用虚拟DOM，那么她是如何根据应用的状态来同步更新UI的呢？让我再次引用Rich Harris的精彩YGLF演讲：</p>
<blockquote>
<p>Frameworks are not tools for organizing your code. They are tools for organizing your mind.<br>框架不是组织代码的工具，框架是用来组织你的思想的。</p>
</blockquote>
<p>正是上面的引用给Rich带来了框架能够在构建阶段运行的灵感，这样代码在运行时就不需要其他中介。这个灵感也导致了Svelte是编译器，而不是框架。</p>
<p>这个简单的想法正是Svelte如此快速的原因。Svelte将你的代码编译为更底层的高效的代码，直接与DOM交互。</p>
<p>上面这些都很棒，但是Svelte是如何避免数据改变时重绘整个DOM呢？Svelte与React的差异在于如何感知数据的改变。我们已经知道，<code>React</code>依赖于用户调用API来感知数据改变，而<code>Svelte</code>只需要简单的使用<code>=</code>就可以了。</p>
<p>如果一个变量—我们假设<code>foo</code>—通过<code>=</code>进行了更新，Svelte只会更新其他依赖于<code>foo</code>的变量。这允许Svelte只更新部分从<code>foo</code>变量中获取值的DOM。</p>
<p>关于其中的细节，可以看<a href="https://www.youtube.com/watch?v=AdNJ3fydeao" target="_blank" rel="noopener">Rich的解释</a></p>
<h2 id="最后一点想法"><a href="#最后一点想法" class="headerlink" title="最后一点想法"></a>最后一点想法</h2><p>Svelte3.0是一段时间内发生的关于软件开发的最好的事情。有些人可以说这有些夸大其词，但是我不这么认为。Svelte背后的理念使得我们在向浏览器中引用更少的模板的同时，做更多的事情。应用也会因此变得更加高性能，更加轻便，同时代码也变得更加优雅和易读。那现在是不是Svelte可以马上取代React，Angular，Vue或者其他前端框架吗？</p>
<p>到目前为止，答案是否定的。相比于这些框架，Svelte相对来说还不是很成熟。它需要时间去成长，变得更加成熟，甚至解决一些目前我们还没有发现的问题。</p>
<p>就像<code>React</code>横空出世改变软件开发模式一样，Svelte也有可能改变我们关于框架的看法，在我们创建新的项目时提供无限可能。</p>
<p>最后，<strong>Happy Coding!</strong></p>
</div><div class="tags"><a href="/tags/%E7%BF%BB%E8%AF%91/"><i class="fa fa-tag"></i>翻译</a><a href="/tags/%E6%96%B0%E9%B2%9C%E8%B4%A7/"><i class="fa fa-tag"></i>新鲜货</a></div><div class="post-nav"><a class="pre" href="/2019/08/14/IE-Chrome-Firefox-http302/">IE-Chrome-Firefox-http302</a><a class="next" href="/2019/05/27/JavaScript-Clean-Code-Best-Practices/">JavaScript Clean Code - Best Practices</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BF%BB%E8%AF%91/">翻译</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/CSS/" style="font-size: 15px;">CSS</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 15px;">网络</a> <a href="/tags/%E7%BF%BB%E8%AF%91/" style="font-size: 15px;">翻译</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" style="font-size: 15px;">浏览器</a> <a href="/tags/%E5%88%A8%E5%9D%91/" style="font-size: 15px;">刨坑</a> <a href="/tags/Nodejs/" style="font-size: 15px;">Nodejs</a> <a href="/tags/%E6%97%A5%E8%AE%B0/" style="font-size: 15px;">日记</a> <a href="/tags/%E6%96%B0%E9%B2%9C%E8%B4%A7/" style="font-size: 15px;">新鲜货</a> <a href="/tags/%E5%BF%83%E6%83%85/" style="font-size: 15px;">心情</a> <a href="/tags/%E9%97%AE%E9%A2%98/" style="font-size: 15px;">问题</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/11/15/diary20201115/">日记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/12/question-to-solve/">问题记录(待解决)</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/26/tcp-flow-conrtol-and-congestion-control/">TCP流量控制和拥塞控制</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/24/BFC/">BFC</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/01/my-terrible-life/">糟糕的开始</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/28/Koa2/">Koa2</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/26/DNS/">DNS</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/24/generator-vs-async-and-await/">Generator Vs Async & Await</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/23/http%E7%BC%93%E5%AD%98/">http缓存</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/21/binary-protocol-vs-text-protocol/">二进制协议和文本协议</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">动力小车.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>